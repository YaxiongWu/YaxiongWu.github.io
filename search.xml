<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[树莓派P3设置静态IP]]></title>
      <url>/2017/06/21/%E6%A0%91%E8%8E%93%E6%B4%BEP3%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
      <content type="html"><![CDATA[<p>　　在新的树莓派系统中，静态IP设置的方法与以前有区别，网上很多设置方法无效，正确的设置方法如下。</p>
<h2 id="1-在-etc-dhcpcd-conf末尾添加"><a href="#1-在-etc-dhcpcd-conf末尾添加" class="headerlink" title="1. 在/etc/dhcpcd.conf末尾添加"></a>1. 在/etc/dhcpcd.conf末尾添加</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#static ip configuration</div><div class="line">interface eth0</div><div class="line">static ip_address=192.168.100.21/24</div><div class="line">static routers=192.168.100.1</div><div class="line">static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4</div><div class="line"> </div><div class="line">interface wlan0</div><div class="line">static ip_address=192.168.100.20/24</div><div class="line">static routers=192.168.100.1</div><div class="line">static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-重启"><a href="#2-重启" class="headerlink" title="2. 重启"></a>2. 重启</h2><pre><code>sudo reboot
</code></pre>]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> 树莓派 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 静态IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32L052的CRC8硬件实现]]></title>
      <url>/2017/06/21/STM32L052%E7%9A%84CRC8%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>　CRC是一种数据校验方式，以CRC8为例，如果有一个字节数组，实现过程是：要校验的字节与一个特定的字节（我们暂且叫做多项式字节）相异或，得出的结果再与前一个字节的结果异或，得出的结果再与多项式字节异或，所得的结果为校验值。这个多项式字节是根据科学计算得出的，能让”数据出错但校验位又没有出错“这种情况发生的概率最低，一般CRC8采用下面三种多项式：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x8+x5+x4+1           0x31（0x131）</div><div class="line">x8+x2+x1+1           0x07（0x107） </div><div class="line">x8+x6+x4+x3+x2+x1    0x5E（0x15E）</div></pre></td></tr></table></figure> </p>
<h2 id="2-c语言实现"><a href="#2-c语言实现" class="headerlink" title="2. c语言实现"></a>2. c语言实现</h2><p>　　由于计算一个字节两次要与多项式字节做异或运算，一般可以采用查表的方式更快得到以后结果<br>　　如果采用多项式 x8+x5+x4+1，那么0-255与多项式相异或的结果如下表所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const uint8_t CRC8Table[]=&#123;    </div><div class="line"> 0x00,0x31,0x62,0x53,0xc4,0xf5,0xa6,0x97,0xb9,0x88,0xdb,0xea,0x7d,0x4c,0x1f,0x2e,</div><div class="line">   0x43,0x72,0x21,0x10,0x87,0xb6,0xe5,0xd4,0xfa,0xcb,0x98,0xa9,0x3e,0x0f,0x5c,0x6d,</div><div class="line">   0x86,0xb7,0xe4,0xd5,0x42,0x73,0x20,0x11,0x3f,0x0e,0x5d,0x6c,0xfb,0xca,0x99,0xa8,</div><div class="line">   0xc5,0xf4,0xa7,0x96,0x01,0x30,0x63,0x52,0x7c,0x4d,0x1e,0x2f,0xb8,0x89,0xda,0xeb,</div><div class="line">   0x3d,0x0c,0x5f,0x6e,0xf9,0xc8,0x9b,0xaa,0x84,0xb5,0xe6,0xd7,0x40,0x71,0x22,0x13,</div><div class="line">   0x7e,0x4f,0x1c,0x2d,0xba,0x8b,0xd8,0xe9,0xc7,0xf6,0xa5,0x94,0x03,0x32,0x61,0x50,</div><div class="line">   0xbb,0x8a,0xd9,0xe8,0x7f,0x4e,0x1d,0x2c,0x02,0x33,0x60,0x51,0xc6,0xf7,0xa4,0x95,</div><div class="line">   0xf8,0xc9,0x9a,0xab,0x3c,0x0d,0x5e,0x6f,0x41,0x70,0x23,0x12,0x85,0xb4,0xe7,0xd6,</div><div class="line">   0x7a,0x4b,0x18,0x29,0xbe,0x8f,0xdc,0xed,0xc3,0xf2,0xa1,0x90,0x07,0x36,0x65,0x54,</div><div class="line">   0x39,0x08,0x5b,0x6a,0xfd,0xcc,0x9f,0xae,0x80,0xb1,0xe2,0xd3,0x44,0x75,0x26,0x17,</div><div class="line">   0xfc,0xcd,0x9e,0xaf,0x38,0x09,0x5a,0x6b,0x45,0x74,0x27,0x16,0x81,0xb0,0xe3,0xd2,</div><div class="line">   0xbf,0x8e,0xdd,0xec,0x7b,0x4a,0x19,0x28,0x06,0x37,0x64,0x55,0xc2,0xf3,0xa0,0x91,</div><div class="line">   0x47,0x76,0x25,0x14,0x83,0xb2,0xe1,0xd0,0xfe,0xcf,0x9c,0xad,0x3a,0x0b,0x58,0x69,</div><div class="line">   0x04,0x35,0x66,0x57,0xc0,0xf1,0xa2,0x93,0xbd,0x8c,0xdf,0xee,0x79,0x48,0x1b,0x2a,</div><div class="line">   0xc1,0xf0,0xa3,0x92,0x05,0x34,0x67,0x56,0x78,0x49,0x1a,0x2b,0xbc,0x8d,0xde,0xef,</div><div class="line">   0x82,0xb3,0xe0,0xd1,0x46,0x77,0x24,0x15,0x3b,0x0a,0x59,0x68,0xff,0xce,0x9d,0xac</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>使用下面的函数就可以得到一个字节数组的CRC8校验值了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> uint8_t CRC8_Table(uint8_t *p, uint8_t counter)    </div><div class="line">&#123;    </div><div class="line"> uint8_t crc8 = 0xff;        </div><div class="line"> for( ; counter &gt; 0; counter--)&#123;    </div><div class="line">   crc8 = CRC8Table[crc8^*p];</div><div class="line">   p++;</div><div class="line">  &#125;    </div><div class="line">  return crc8;        </div><div class="line">&#125;    </div></pre></td></tr></table></figure></p>
<h2 id="3-在stm32l052中实现CRC"><a href="#3-在stm32l052中实现CRC" class="headerlink" title="3. 在stm32l052中实现CRC"></a>3. 在stm32l052中实现CRC</h2><p>　　由于CRC在数据传输中要经常用到，Stm32l052有专门的硬件CRC，可以完成7、8、16和32位的CRC， 在官方给出的实例中，实现的是默认32位CRC，下面介绍的如何使用硬件完成CRC8:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CrcHandle.Instance = CRC;   </div><div class="line">CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;//DEFAULT_POLYNOMIAL_ENABLE;</div><div class="line">CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_ENABLE;</div><div class="line">CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;</div><div class="line">CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;</div><div class="line">CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;//CRC_INPUTDATA_FORMAT_WORDS;</div><div class="line">CrcHandle.Init.CRCLength=CRC_POLYLENGTH_8B;</div><div class="line">CrcHandle.Init.GeneratingPolynomial=0x31;</div><div class="line">HAL_CRC_DeInit(&amp;CrcHandle);</div><div class="line">HAL_CRC_Init(&amp;CrcHandle);</div><div class="line"></div><div class="line">if(HAL_CRC_Init(&amp;CrcHandle) != HAL_OK)</div><div class="line">&#123;   </div><div class="line"> Error_Handler();</div><div class="line">&#125;</div><div class="line">uwCRCValue = HAL_CRC_Accumulate(&amp;CrcHandle, (uint32_t *)aDataBuffer,24);// BUFFER_SIZE);</div></pre></td></tr></table></figure><br>注意以下几个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE; </div><div class="line">CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;</div><div class="line">CrcHandle.Init.CRCLength =    CRC_POLYLENGTH_8B;</div><div class="line">CrcHandle.Init.GeneratingPolynomial = 0x31;</div><div class="line"> </div></pre></td></tr></table></figure><br>　前三个参数是指定使用CRC8，后面GeneratingPolynomial 是多项式，去掉最高位，如 （x8+x5+x4+1）设置为0x31，在实例代码和说明书中，默认的32位CRC为X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2+ X +1，去掉最高位，对应设置的值为0x4C11DB7。</p>
<div class="tip"><br>　注意<p><br>　如果设置了为8位，在计算时，HAL_CRC_Accumulate函数的第二个参数虽然是32位的，但最后一个参数是指有多个个字节，这个参数到底是以8位、16位还是32位算，是与设置InputDataFormat相关的.</p><p><br>　最后注意使用硬件和代码分别实现时，初始值设置要一致。</p><p><br>　通过验证，硬件实现的CRC8与代码实现的一致。<br></p></div> ]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> crc8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32的ADC测量电压]]></title>
      <url>/2017/06/21/STM32%E7%9A%84ADC%E6%B5%8B%E9%87%8F%E7%94%B5%E5%8E%8B/</url>
      <content type="html"><![CDATA[<p>　　设备使用锂电池供电，需要使用ADC来测量电池电压，使用过程中遇到一些问题记录如下：</p>
<h2 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1. 硬件"></a>1. 硬件</h2><p>　　由于电池电压为2.4~4.2v，超过了ADC测量范围，需要分压，为了节约电量，分压采用了比较大的电阻，两个33K，测试时很不准，最后查资料发现是分压电路的电流跟不上，<br><a id="more"></a>也可以认为是输入电阻的匹配问题，联想到以前学习的精确测量小电压的差分放大电路，可以得知使用这种大电阻分压无法测得电压值，最后折中的办法是在需测量电压上加了一个2.2uF电容，这样保证测量时的电量供应，改进之后测量基本准确。</p>
<h2 id="2-软件"><a href="#2-软件" class="headerlink" title="2. 软件"></a>2. 软件</h2><p>　　在64脚以下的stm32芯片一般没有Vref，只能用芯片电源电压VDD作为ADC的参考电压，但如果是电池供电，该电源电压又是变动的，这就需要利用MCU芯片内部自带基准电压对电源电压进行监测。<br>　　每一个型号的基准电压不一致，STM32L052为3v，其他的有为1.2V的，而且一个芯片的校准值也不一样，保存在VREFINT_CAL中，以STM32L052为例，VDDA=3V /<em> VREFINT_CAL/VREFINT_DATA，这里得到的只是ADC测量的参考电压。如果使用12位采样，实际测得的ADC电压值为VDDA/</em>ADC通道采样值/4096。如果电压是稳定的在3.3v，就可以不用测量VDDA这一步了。<br><img src="/images/201706221026_ADC.png" alt="图片"><br>　　这里关键需要厘清的是：内部参考电压VREFINT并非ADC的参考电压，ADC的参考电压依然是VDD。即使VDD有所波动，这个VREFINT电压恒定不变，对于ADC电路而言，它只是个测试点，它的作用是测出VDDA。</p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ADC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32 Spi DMA]]></title>
      <url>/2017/06/21/STM32-Spi-DMA/</url>
      <content type="html"><![CDATA[<p>　　为了能减轻CPU的负担，考虑使用DMA来操作SPI，但由于SPI为主从模式，主机需要读取从机数据时，也是由主机发起的，如果使用DMA，主机要读从机数据时，先将发送缓存指向发送地址等，使能DMA之后就结束了，需要等到DMA接收完成的中断产生后，才能读接收缓冲，这个过程操作很复杂，<a id="more"></a>而且下一次发送时，需要等待判断、等待前一次，启动DMA后，还要等待接收的数据，等中断产生后，才能得带有效的接收数据，所以从效率上来说，只有对存储类和摄像头之类的大块数据才有意义，要频繁改变的小数据没有必要使用DMA，控制太复杂，跟串口的接收数据在形式上有区别。<br>　　现将SPI的DMA操作步骤和注意事项记录如下：</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">SPIx_SCK_GPIO_CLK_ENABLE();</div><div class="line">SPIx_MISO_GPIO_CLK_ENABLE();</div><div class="line">SPIx_MOSI_GPIO_CLK_ENABLE();</div><div class="line">/* Enable SPI clock */</div><div class="line">SPIx_CLK_ENABLE();</div><div class="line">/*##-2- Configure peripheral GPIO ##########################################*/</div><div class="line">/* SPI SCK GPIO pin configuration  */</div><div class="line">GPIO_InitTypeDef  GPIO_InitStruct;</div><div class="line">GPIO_InitStruct.Pin       = SPIx_SCK_PIN;</div><div class="line">GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;</div><div class="line">GPIO_InitStruct.Pull      = GPIO_PULLDOWN;</div><div class="line">GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_LOW;</div><div class="line">HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &amp;GPIO_InitStruct);</div><div class="line">/* SPI MISO GPIO pin configuration  */</div><div class="line">GPIO_InitStruct.Pin = SPIx_MISO_PIN;</div><div class="line">HAL_GPIO_Init(SPIx_MISO_GPIO_PORT, &amp;GPIO_InitStruct);</div><div class="line">/* SPI MOSI GPIO pin configuration  */</div><div class="line">GPIO_InitStruct.Pin = SPIx_MOSI_PIN;</div><div class="line">HAL_GPIO_Init(SPIx_MOSI_GPIO_PORT, &amp;GPIO_InitStruct);</div><div class="line">GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;</div><div class="line">GPIO_InitStruct.Pull  = GPIO_PULLUP;</div><div class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</div><div class="line">GPIO_InitStruct.Pin = RC522_CS_PIN;</div><div class="line">HAL_GPIO_Init(RC522_CS_GPIO_PORT, &amp;GPIO_InitStruct);</div><div class="line">RC522_CS_GPIO_CLK_ENABLE();</div><div class="line">GPIO_InitStruct.Pin = RC522_RESET_PIN;</div><div class="line">HAL_GPIO_Init(RC522_RESET_GPIO_PORT, &amp;GPIO_InitStruct);</div><div class="line">RC522_RESET_GPIO_CLK_ENABLE();</div><div class="line">HAL_GPIO_WritePin(RC522_RESET_GPIO_PORT,RC522_RESET_PIN,1);</div><div class="line">/*##-3- Configure the NVIC for SPI #########################################*/</div><div class="line">/* NVIC for SPI */</div><div class="line">/*##-1- Configure the SPI peripheral #######################################*/</div><div class="line">/* Set the SPI parameters */</div><div class="line">SpiHandle.Instance               = SPIx;</div><div class="line">SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;</div><div class="line">SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;</div><div class="line">SpiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;</div><div class="line">SpiHandle.Init.CLKPolarity       = SPI_POLARITY_LOW;</div><div class="line">SpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;</div><div class="line">SpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;</div><div class="line">SpiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;</div><div class="line">SpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;</div><div class="line">SpiHandle.Init.CRCPolynomial     = 7;</div><div class="line">SpiHandle.Init.NSS               = SPI_NSS_SOFT;</div><div class="line">SpiHandle.Init.Mode = SPI_MODE_MASTER;</div><div class="line">if(HAL_SPI_Init(&amp;SpiHandle) != HAL_OK)</div><div class="line">&#123;</div><div class="line">/* Initialization Error */</div><div class="line">//Error_Handler();</div><div class="line">&#125;</div><div class="line">__HAL_SPI_ENABLE(&amp;SpiHandle);</div><div class="line">DMAx_CLK_ENABLE();</div><div class="line">/*##-3- Configure the DMA ##################################################*/</div><div class="line">/* Configure the DMA handler for Transmission process */</div><div class="line">hdma_tx.Instance                 = SPIx_TX_DMA_CHANNEL;</div><div class="line">hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;</div><div class="line">hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;</div><div class="line">hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;</div><div class="line">hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</div><div class="line">hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;</div><div class="line">hdma_tx.Init.Mode                = DMA_NORMAL;</div><div class="line">hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;</div><div class="line">HAL_DMA_Init(&amp;hdma_tx);</div><div class="line">/* Associate the initialized DMA handle to the the SPI handle */</div><div class="line">__HAL_LINKDMA(&amp;SpiHandle, hdmatx, hdma_tx);</div><div class="line">/* Configure the DMA handler for Transmission process */</div><div class="line">hdma_rx.Instance                 = SPIx_RX_DMA_CHANNEL;</div><div class="line">hdma_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;</div><div class="line">hdma_rx.Init.PeriphInc           = DMA_PINC_DISABLE;</div><div class="line">hdma_rx.Init.MemInc              = DMA_MINC_ENABLE;</div><div class="line">hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</div><div class="line">hdma_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;</div><div class="line">hdma_rx.Init.Mode                = DMA_NORMAL;</div><div class="line">hdma_rx.Init.Priority            = DMA_PRIORITY_HIGH;</div><div class="line">HAL_DMA_Init(&amp;hdma_rx);</div><div class="line">/* Associate the initialized DMA handle to the the SPI handle */</div><div class="line">__HAL_LINKDMA(&amp;SpiHandle, hdmarx, hdma_rx);</div><div class="line">//DMA_ITConfig(DMA1_Channel5, DMA_IT_TC, ENABLE);</div><div class="line">/*##-4- Configure the NVIC for DMA #########################################*/ </div><div class="line">/* NVIC configuration for DMA transfer complete interrupt (SPI2_TX) */</div><div class="line">HAL_NVIC_SetPriority(SPIx_DMA_TX_IRQn, 0, 1);</div><div class="line">HAL_NVIC_EnableIRQ(SPIx_DMA_TX_IRQn);</div><div class="line">/* NVIC configuration for DMA transfer complete interrupt (SPI2_RX) */</div><div class="line">HAL_NVIC_SetPriority(SPIx_DMA_RX_IRQn, 0, 0);</div><div class="line">HAL_NVIC_EnableIRQ(SPIx_DMA_RX_IRQn);</div><div class="line">HAL_NVIC_SetPriority(SPIx_IRQn, 1, 0);</div><div class="line">HAL_NVIC_EnableIRQ(SPIx_IRQn); </div></pre></td></tr></table></figure>
<h2 id="2-发送接收"><a href="#2-发送接收" class="headerlink" title="2. 发送接收"></a>2. 发送接收</h2><p>　　注意发送接收缓冲区需要全局变量，因为使用DMA启动后，函数就退出了，如果在函数里使用局部变量，函数退出后变量被回收，这个缓冲区可能会用在别的地方，再对它读写会造成混乱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while(HAL_SPI_GetState(&amp;SpiHandle)!=HAL_SPI_STATE_READY)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line">//HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,1);</div><div class="line">HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,0);</div><div class="line">if(HAL_SPI_TransmitReceive_DMA(&amp;SpiHandle,txData,rxData,2)!= HAL_OK)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-中断处理"><a href="#3-中断处理" class="headerlink" title="3. 中断处理"></a>3. 中断处理</h2><p>　　将NSS脚拉高，清除中断标志。注意DMA中断有DMA的传输一半、传输完成和出错三个中断，如果不判断，传输一半NSS脚会被拉高，也可以在  HAL_SPI_TransmitReceive_DMA( )函数的HAL_DMA_Start_IT()中，屏蔽掉传输过半的中断__HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> void DMA1_Channel4_IRQHandler(void)</div><div class="line"> &#123; </div><div class="line"> if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(SpiHandle.hdmarx)) != RESET)</div><div class="line"> &#123;</div><div class="line">  if(__HAL_DMA_GET_IT_SOURCE(SpiHandle.hdmarx, DMA_IT_TC) != RESET)</div><div class="line">  &#123;</div><div class="line">   HAL_DMA_IRQHandler(SpiHandle.hdmarx);</div><div class="line">   HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,1);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"> void DMA1_Channel5_IRQHandler(void)</div><div class="line"> &#123;</div><div class="line">  HAL_DMA_IRQHandler(SpiHandle.hdmatx);</div><div class="line"> &#125;</div><div class="line"> </div></pre></td></tr></table></figure> </p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DMA </tag>
            
            <tag> SPI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32f103 uart dma printf串口终极方案]]></title>
      <url>/2017/06/21/STM32f103-uart-dma-printf%E4%B8%B2%E5%8F%A3%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>　　stm32有dma功能，使用dma功能能大大减少CPU占用率，减少数据传输过程中被中断的几率，但是官方提供的DMA程序是固定长度接收DMA的，DMA接收时只有达到指定的接收长度才会参数中断，但是UART有一个空闲中断，这样可以先开启DMA接收，等UART接收完数据后会产生IDLE中断，进入中断后停掉DMA接收，<a id="more"></a>通过DMA的剩余接收空间可以得出本次接收到的数据长度。<br>　　下面的实验从cube驱动uart的UART_HyperTerminal_DMA实例修改：</p>
<h2 id="1-前期工作"><a href="#1-前期工作" class="headerlink" title="1. 前期工作"></a>1. 前期工作</h2><p>　　将各配置按实际的电路板配置好，实现原本实例想实现的定长串口接收功能</p>
<h2 id="2-在main-c中定义收发需要的参数"><a href="#2-在main-c中定义收发需要的参数" class="headerlink" title="2. 在main.c中定义收发需要的参数"></a>2. 在main.c中定义收发需要的参数</h2><pre><code>uint8_t aRxBuffer[RXBUFFERSIZE];
uint8_t UartRecCount=0;  
uint8_t txbuf2[100];
</code></pre><p>  在main()主函数中开启IDLE中断<br>    __HAL_UART_ENABLE_IT(&amp;UartHandle, UART_IT_IDLE);</p>
<h2 id="3-在中断程序中修改IDLE中断响应"><a href="#3-在中断程序中修改IDLE中断响应" class="headerlink" title="3. 在中断程序中修改IDLE中断响应"></a>3. 在中断程序中修改IDLE中断响应</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">extern uint8_t aRxBuffer[RXBUFFERSIZE];</div><div class="line">extern uint8_t UartRecCount;</div><div class="line">void USARTx_IRQHandler(void)</div><div class="line">&#123;</div><div class="line"> uint32_t temp;</div><div class="line"> if((__HAL_UART_GET_FLAG(&amp;UartHandle, UART_FLAG_IDLE) != RESET))</div><div class="line"> &#123;</div><div class="line">  __HAL_UART_CLEAR_IDLEFLAG(&amp;UartHandle);</div><div class="line">  HAL_UART_DMAStop(&amp;UartHandle);</div><div class="line">  temp  = UartHandle.hdmarx-&gt;Instance-&gt;CNDTR;</div><div class="line">  UartRecCount =  RXBUFFERSIZE - temp;</div><div class="line">  __HAL_UART_ENABLE_IT(&amp;UartHandle, UART_IT_IDLE);</div><div class="line">  UartHandle.hdmarx-&gt;State = HAL_DMA_STATE_READY;</div><div class="line">  HAL_UART_Receive_DMA(&amp;UartHandle,(uint8_t *)aRxBuffer, RXBUFFERSIZE);</div><div class="line">  HAL_UART_Transmit_DMA(&amp;UartHandle, (uint8_t *)aRxBuffer, UartRecCount);//测试，发出收到的变长数据</div><div class="line"> &#125;</div><div class="line"> HAL_UART_IRQHandler(&amp;UartHandle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-printf"><a href="#4-printf" class="headerlink" title="4. printf"></a>4. printf</h2><p>　　在main.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">uint8_t printfBuf[20];</div><div class="line">void dma_printf(const char *format, ...)</div><div class="line">&#123;</div><div class="line">  uint32_t length;</div><div class="line">  va_list args;</div><div class="line">  va_start(args, format);</div><div class="line">  length = vsnprintf((char *)printfBuf, sizeof(printfBuf), (char *)format, args);</div><div class="line">  va_end(args);</div><div class="line">  HAL_UART_Transmit_DMA(&amp;UartHandle, (uint8_t *)printfBuf, length);</div><div class="line">&#125; </div></pre></td></tr></table></figure><br>之后可以调用dma_printf(“test %d \n\r”,10);之类的串口输出</p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DMA </tag>
            
            <tag> UART </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32L0 Lorawan调试问题]]></title>
      <url>/2017/06/21/STM32L0-Lorawan%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-RTC-设置和PLL问题"><a href="#1-RTC-设置和PLL问题" class="headerlink" title="1. RTC 设置和PLL问题"></a>1. RTC 设置和PLL问题</h2><p>　　在调试RTC时，时钟一直有问题，后测试发现PLL需要在先设置RCC_CLOCKTYPE_SYSCLK后再设置，不能一次性使用(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);具体原因有待进一步分析，从时钟树的图上开，HCLK、PCLK1、PCLK2都是以SYSCLK为基础的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">void SystemClock_Config( void )</div><div class="line">&#123;</div><div class="line">   RCC_ClkInitTypeDef RCC_ClkInitStruct;</div><div class="line">   RCC_OscInitTypeDef RCC_OscInitStruct;</div><div class="line">  /* Enable Power Control clock */</div><div class="line">  __HAL_RCC_PWR_CLK_ENABLE();</div><div class="line">  /* The voltage scaling allows optimizing the power consumption when the device is </div><div class="line">   clocked below the maximum system frequency, to update the voltage scaling value </div><div class="line">   regarding system frequency refer to product datasheet.  */</div><div class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);</div><div class="line">   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;</div><div class="line">   RCC_OscInitStruct.HSEState = RCC_HSE_ON;</div><div class="line">   RCC_OscInitStruct.LSEState = RCC_LSE_ON;</div><div class="line">   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</div><div class="line">   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</div><div class="line">   RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;</div><div class="line">   RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;</div><div class="line">   HAL_RCC_OscConfig( &amp;RCC_OscInitStruct );</div><div class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;//(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</div><div class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;// RCC_SYSCLKSOURCE_MSI;</div><div class="line">  if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)</div><div class="line">  &#123;</div><div class="line">   /* Initialization Error */</div><div class="line">   Error_Handler();</div><div class="line">  &#125;</div><div class="line">  RCC_ClkInitStruct.ClockType =( RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</div><div class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</div><div class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;  </div><div class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;  </div><div class="line">  if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)</div><div class="line">  &#123;</div><div class="line">   /* Initialization Error */</div><div class="line">   Error_Handler();</div><div class="line">  &#125;</div><div class="line">  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;</div><div class="line">  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;</div><div class="line">  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;</div><div class="line">  if(HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)</div><div class="line">  &#123; </div><div class="line">   while(1)</div><div class="line">   &#123;</div><div class="line">   /* Turn LED3 on */</div><div class="line">   BSP_LED_Toggle(LED3);</div><div class="line">   /* Add a 100ms Delay */</div><div class="line">   HAL_Delay(100);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">  __HAL_RCC_RTC_ENABLE();   </div><div class="line">  /*##-3- Configure the NVIC for RTC Alarm ###################################*/</div><div class="line">  HAL_NVIC_SetPriority(RTC_IRQn, 0x0, 0);</div><div class="line">  HAL_NVIC_EnableIRQ(RTC_IRQn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-RTC时钟设置问题"><a href="#2-RTC时钟设置问题" class="headerlink" title="2. RTC时钟设置问题"></a>2. RTC时钟设置问题</h2><p>　　如果RTC的时钟使用LSE，RTC的计时、闹钟由LSE和SynchPrediv、AsynchPrediv 决定，<br>   1 Hz =32768 / ((AsynchPrediv+1)x(SynchPrediv+1))，<br>　　使用闹钟定时时，除了比较到秒级外，还可以比较subSeconds，subSeconds在设置时间时是不能设置的，它由SynchPrediv决定，新的一秒开始后，它从SynchPrediv开始递减，到0后进入下一秒，实验证明至少要设置到下两个subSeconds才能产生闹钟中断，只有一个不行，如果要设置到1ms的定时，SynchPrediv就需要设置到2047(0x07FF)，这样AsynchPrediv设为0x0F。<br> 　　所以原代码<br>    RtcHandle.Init.AsynchPrediv = 3;<br>    RtcHandle.Init.SynchPrediv =  3;<br>改为<br>    RtcHandle.Init.AsynchPrediv = 0x0F;<br>    RtcHandle.Init.SynchPrediv =  0x07FF;</p>
<h2 id="3-定时器问题"><a href="#3-定时器问题" class="headerlink" title="3. 定时器问题"></a>3. 定时器问题</h2><p>　　原来代码的RtcComputeTimerTimeToAlarmTick输入的是毫秒，在函数里当秒用，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">static RtcCalendar_t RtcComputeTimerTimeToAlarmTick( TimerTime_t timeMiliSecond, RtcCalendar_t now )</div><div class="line">&#123;</div><div class="line">   RtcCalendar_t calendar = now;</div><div class="line">   uint16_t seconds = now.CalendarTime.Seconds;</div><div class="line">   uint16_t minutes = now.CalendarTime.Minutes;</div><div class="line">   uint16_t hours = now.CalendarTime.Hours;</div><div class="line">   uint16_t days = now.CalendarDate.Date;</div><div class="line">   uint32_t nowSubSecondTick=now.CalendarTime.SubSeconds;</div><div class="line">   //double timeoutValueTemp = 0.0;</div><div class="line">   // double timeoutValueSecond = 0.0;</div><div class="line">   // double timeoutValue = 0.0;</div><div class="line">   // double error = 0.0;</div><div class="line">  uint32_t alarmSubSecondTick=0;</div><div class="line">  // int32_t  subSecondTemp=0;</div><div class="line">   timeMiliSecond = MIN( timeMiliSecond, ( TimerTime_t )( RTC_ALARM_MAX_NUMBER_OF_DAYS * SecondsInDay * RTC_ALARM_TICK_DURATION ) );</div><div class="line">   if( timeMiliSecond &lt; 1 )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond = 1;</div><div class="line">   &#125;</div><div class="line">  // timeoutValue is used for complete computation</div><div class="line">  //tickSubSecond = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line"></div><div class="line">  /*</div><div class="line">   // timeoutValueTemp is used to compensate the cumulating errors in timing far in the future</div><div class="line">   timeoutValueTemp =  ( double )timeCounter * RTC_ALARM_TICK_PER_MS;</div><div class="line">   // Compute timeoutValue error</div><div class="line">   error = timeoutValue - timeoutValueTemp;</div><div class="line">   // Add new error value to the cumulated value in uS</div><div class="line">   TimeoutValueError += ( error  * 1000 );</div><div class="line">   // Correct cumulated error if greater than ( RTC_ALARM_TICK_DURATION * 1000 )</div><div class="line">   if( TimeoutValueError &gt;= ( int32_t )( RTC_ALARM_TICK_DURATION * 1000 ) )</div><div class="line">   &#123;</div><div class="line">   TimeoutValueError = TimeoutValueError - ( uint32_t )( RTC_ALARM_TICK_DURATION * 1000 );</div><div class="line">   timeoutValue = timeoutValue + 1;</div><div class="line">   &#125;</div><div class="line"> */</div><div class="line">  // Convert milliseconds to RTC format and add to now</div><div class="line">  //timeoutValueSecond=timeoutValue/1000;</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInDay )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInDay;</div><div class="line">   days++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Calculate hours</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInHour )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInHour;</div><div class="line">   hours++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Calculate minutes</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInMinute )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInMinute;</div><div class="line">   minutes++;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">  while( timeMiliSecond &gt;= MiliSecondsInSecond )</div><div class="line">  &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInSecond;</div><div class="line">   seconds++;</div><div class="line">  &#125;</div><div class="line">  alarmSubSecondTick = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line">  // Calculate seconds</div><div class="line">  //subSecondTemp=nowSubSecondTick - alarmSubSecondTick;</div><div class="line">  //nowSubSecondTick=nowSubSecondTick + round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line">  if(nowSubSecondTick &lt; alarmSubSecondTick)</div><div class="line">  &#123;</div><div class="line">   seconds++;</div><div class="line">   alarmSubSecondTick=RTC_ALARM_TICK_PER_SECOND-(alarmSubSecondTick - nowSubSecondTick  );</div><div class="line">  &#125; </div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   alarmSubSecondTick=nowSubSecondTick-alarmSubSecondTick ;</div><div class="line">  &#125;</div><div class="line">  // Correct for modulo</div><div class="line">  while( seconds &gt;= 60 )</div><div class="line">  &#123; </div><div class="line">   seconds -= 60;</div><div class="line">   minutes++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while( minutes &gt;= 60 )</div><div class="line">  &#123;</div><div class="line">   minutes -= 60;</div><div class="line">   hours++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while( hours &gt;= HoursInDay )</div><div class="line">  &#123;</div><div class="line">   hours -= HoursInDay;</div><div class="line">   days++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + Century ) % 4 ) == 0 )</div><div class="line">  &#123;</div><div class="line">   if( days &gt; DaysInMonthLeapYear[now.CalendarDate.Month - 1] )</div><div class="line">   &#123;</div><div class="line">   days = days % DaysInMonthLeapYear[now.CalendarDate.Month - 1];</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   if( days &gt; DaysInMonth[now.CalendarDate.Month - 1] )</div><div class="line">   &#123;   </div><div class="line">   days = days % DaysInMonth[now.CalendarDate.Month - 1];</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">   calendar.CalendarTime.SubSeconds=alarmSubSecondTick;</div><div class="line">   calendar.CalendarTime.Seconds = seconds;</div><div class="line">   calendar.CalendarTime.Minutes = minutes;</div><div class="line">   calendar.CalendarTime.Hours = hours;</div><div class="line">   calendar.CalendarDate.Date = days;</div><div class="line">   return calendar;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br>相应的RtcConvertCalendarTickToTimerTime也改成毫秒，修改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> static TimerTime_t RtcConvertCalendarTickToTimerTime( RtcCalendar_t *calendar )</div><div class="line"> &#123;</div><div class="line">   TimerTime_t timeCounter = 0;</div><div class="line">   RtcCalendar_t now;</div><div class="line">   double timeCounterTemp = 0.0;</div><div class="line">  // Passing a NULL pointer will compute from &quot;now&quot; else,</div><div class="line">  // compute from the given calendar value</div><div class="line">   if( calendar == NULL )</div><div class="line">   &#123;</div><div class="line">   now = RtcGetCalendar( );</div><div class="line">   &#125;</div><div class="line">  else</div><div class="line">   &#123;</div><div class="line">   now = *calendar;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Years (calculation valid up to year 2099)</div><div class="line">   for( int16_t i = 0; i &lt; ( now.CalendarDate.Year + now.CalendarCentury ); i++ )</div><div class="line">   &#123;</div><div class="line">   if( ( i == 0 ) || ( i % 4 ) == 0 )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )SecondsInLeapYear;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )SecondsInYear;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Months (calculation valid up to year 2099)*/</div><div class="line">  if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + now.CalendarCentury ) % 4 ) == 0 )</div><div class="line">   &#123;</div><div class="line">   for( uint8_t i = 0; i &lt; ( now.CalendarDate.Month - 1 ); i++ )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )( DaysInMonthLeapYear[i] * SecondsInDay );</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   for( uint8_t i = 0;  i &lt; ( now.CalendarDate.Month - 1 ); i++ )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )( DaysInMonth[i] * SecondsInDay );</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  timeCounterTemp += ( double )( ( uint32_t )now.CalendarTime.Seconds +</div><div class="line">                     ( ( uint32_t )now.CalendarTime.Minutes * SecondsInMinute ) +</div><div class="line">                     ( ( uint32_t )now.CalendarTime.Hours * SecondsInHour ) +</div><div class="line">                     ( ( uint32_t )now.CalendarDate.Date * SecondsInDay )  );</div><div class="line"></div><div class="line">   timeCounterTemp = ( double )timeCounterTemp*1000 +(RTC_ALARM_TICK_PER_SECOND- now.CalendarTime.SubSeconds )* RTC_ALARM_TICK_DURATION;</div><div class="line">   timeCounter = round( timeCounterTemp );</div><div class="line">   return ( timeCounter );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-1秒内定时问题"><a href="#3-1秒内定时问题" class="headerlink" title="3. 1秒内定时问题"></a>3. 1秒内定时问题</h2><p>　　RTC时钟只计时到1秒，那么如何定时1秒呢，接收窗口1的延时一般都是1秒，如果在0.9的时候开始设置，那么0.1秒后就产生中断了，显然不合适，这需要设置subSecondsMask，只有在subSecond也一样时才产生中断。<br>    alarmStructure.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;</p>
<h2 id="4-1276初始化问题"><a href="#4-1276初始化问题" class="headerlink" title="4. 1276初始化问题"></a>4. 1276初始化问题</h2><p>　　设置顺序，    SX1276IoIrqInit( DioIrq )原来放在参数写之前，如果这样，在写的时候，可能会参数中断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for( i = 0; i &lt; sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )</div><div class="line">&#123;</div><div class="line"> SX1276SetModem( RadioRegsInit[i].Modem );</div><div class="line"> SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );</div><div class="line">&#125;</div><div class="line">SX1276SetModem( MODEM_FSK );</div><div class="line">SX1276.Settings.State = RF_IDLE;</div><div class="line">SX1276IoIrqInit( DioIrq );</div></pre></td></tr></table></figure><br>　　ST官网的lorawan1.0.1源码解决了以上问题。</p>
<h2 id="5-470的移植问题"><a href="#5-470的移植问题" class="headerlink" title="5. 470的移植问题"></a>5. 470的移植问题</h2><p>　　470和915本来上行和下行的频率不一样。<br>　　在 LoRaMac.c的ResetMacParameters( void )函数中，设置了默认的可用频道，915和470的LoRaMacParams.ChannelsMask并没有被赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> memcpy1( ( uint8_t* ) LoRaMacParams.ChannelsMask, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );</div><div class="line">#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID ) ||defined( USE_BAND_470 )</div><div class="line"> memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>但是在SetNextChannel（）中915又使用了LoRaMacParams.ChannelsMask，显然是有问题的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID )</div><div class="line"> if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )</div><div class="line"> &#123; // Restore default channels</div><div class="line">  memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParams.ChannelsMask, 8 );</div><div class="line"> //这里应该有问题，应该是LoRaMacParamsDefaults.ChannelsMask</div><div class="line"> &#125;</div><div class="line"> if( ( LoRaMacParams.ChannelsDatarate &gt;= DR_4 ) &amp;&amp; ( ( ChannelsMaskRemaining[4] &amp; 0x00FF ) == 0 ) )</div><div class="line"> &#123; // Make sure, that the channels are activated</div><div class="line">  ChannelsMaskRemaining[4] = LoRaMacParams.ChannelsMask[4];</div><div class="line"> &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>   在470使用了 LoRaMacParamsDefaults.ChannelsMask，实测功能正确<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#elif defined( USE_BAND_470 )</div><div class="line">if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )</div><div class="line">&#123; // Restore default channels</div><div class="line"> memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, 12 );</div><div class="line">&#125;</div><div class="line">OnRxWindow1TimerEvent（） 函数中，如果按协议，上下行频率不一样，470应该这样才对：</div><div class="line">// RxWindowSetup( LORAMAC_FIRST_RX2_CHANNEL + ( Channel % 48 ) * LORAMAC_STEPWIDTH_RX2_CHANNEL, datarate,     bandwidth, symbTimeout, false );</div></pre></td></tr></table></figure><br>　　但是实测semtech的服务器上下频率一直，所以用下面的，实测可OTAA 和收发数据<br>    RxWindowSetup( Channels[Channel].Frequency, datarate, bandwidth, symbTimeout, false );</p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lorawan </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32L0不能连接的问题]]></title>
      <url>/2017/06/21/STM32L0%E4%B8%8D%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>　　前期使用STM32L052+SX1276模块时，遇到了几个问题：</p>
<ol>
<li>使用买来的，已经写好代码的MODEM，直接就不认，一直纠结于硬件问题，或是启动设置的问题，其实是写好的代码中，将SW调试端口用作了IO口，只要正常运行后，就无法正常的用作SW，所以一直连不上，ST-LINK软件的提示是有意义的，它提示使用硬件RESET，这个在”STM32 ST-LINK Utility”和keil中都有地方设置，原理就是SW的IO口做别的用了，就通过RESET来复位到SW，一般是点击连接，或下载，或调试时，立即按下RESET，很快松开，可正常使用<a id="more"></a></li>
<li>FLASH的读保护问题<br>   在连接FLASH后，提示读保护，网上大部分是让从RAM运行一段FLASH解锁的代码，有些复杂，没有成功。<br>  解决办法：<br>   连接板子与PC，进入Dos命令行，进入C:\Program Files <x86>\STMicroelectronics\STM32 ST-LINK Utility\ST-LINK Utility目录下，执行ST-Link_CLI.exe -c SWD UR -OB RDP=0  这样就可以把读保护去掉了。</x86></li>
</ol>
<h2 id="2-网上有价值的信息"><a href="#2-网上有价值的信息" class="headerlink" title="2. 网上有价值的信息"></a>2. 网上有价值的信息</h2><p>　　很多人都碰到过调试器不能连接到STM32的问题，不管是IAR的J-Link还是Keil的ULink，或者是ST的ST-Link。出现这个问题时，调试软件会提示不能建立与Cortex-M3的连接，或提示不能下载程序，或提示找不到要调试的设备等。<br>这样的问题都是发生在调试那些可以在CPU不干预的时候自动运行的模块、或在调试低功耗模式的程序的时候。所谓“可以在CPU不干预的时候自动运行的模块”包括：DMA、定时器、连续转换模式下的ADC、看门狗等模块。</p>
<p>　　这个问题的根源是：</p>
<ol>
<li>调试器需要在RAM内执行一段程序，对Flash进行擦写操作，如果不停止这些自动运行的模块，它们会干扰程序在RAM中的执行，致使下载失败。比如DMA模块被配置为不停地拷贝一段数据区，而调试器刚好需要使用DMA数据传输的目标区域，这时DMA的操作将会与调试器的操作发生冲突。再比如，如果启动了看门狗而没有执行硬件复位，则在下次调试器需要下载程序时，看门狗超时将触发芯片复位，导致下载操作失败。</li>
<li>低功耗是通过停止CPU的时钟而实现，JTAG调试是通过与CPU的通信实现，停止了CPU的时钟致使调试器会失去与CPU的通信。</li>
</ol>
<p>　　有人说“我停止调试的时候，这些模块已经停止了运行，应该不会干扰到后续的调试”，这个问题要从几方面看：</p>
<ol>
<li>调试器是通过停止CPU核心的时钟来停止被调试程序的运行，实际上被调试芯片的硬件模块并没有被复位，它们还处于使能状态，那些能够自动运行的模块只是处于暂停状态，一旦恢复了时钟之后，它们仍会继续运行。</li>
<li>目前常用的调试软件，不管是IAR EWARM还是Keil MDK，调试软件界面上的”复位”按钮都不能对芯片执行硬件的复位，这个”复位”按钮只能对芯片内的程序执行软件复位，即把运行指针重新指向复位地址。</li>
<li>使用板上的复位按钮可以手动地进行硬件复位，使所有模块(包括那些能够自动运行的模块)停止工作并恢复到复位状态。但是当调试器需要控制CPU之前，它需要先为CPU核心提供时钟，然后需要较长的一段时间做一些初始化的动作，然后才能接管CPU核心的控制权。在调试器为CPU核心提供时钟之后，用户程序就已经开始运行起来，如果用户程序在调试器接管CPU核心的控制权之前，就初始化好硬件模块并启动运行，则仍然会产生与调试器的冲突。</li>
</ol>
<p>　　根据以上的分析，解决这个问题的关键是，在调试器接管CPU核心的控制权之前，必须停止所有能够自动运行模块的操作，使它们处于关闭状态，要做到这一点，可以有以下几种方案：</p>
<ol>
<li>每次退出调试状态时，先停止所有模块的运行，比如执行该模块的DeInit()操作。</li>
<li>在main()函数开始时，不管各模块处于什么状态，先执行该模块的DeInit()操作，然后在程序中较晚的时间或真正需要时再开启相应的模块。这样保证在刚进入调试状态时，调试器能够有充足的时间完成初始化和下载程序的操作。先执行该模块的DeInit()操作的目的是为了关闭哪些上一次操作开启的模块。</li>
<li>调整BOOT0/BOOT1的设置，把启动模式改变为从内部SRAM启动，再结合手工硬件复位。由于BOOT0/BOOT1的状态只在硬件复位时是有意义的，而调试器不做硬件复位，所以这样的设置不会影响调试器下载程序到Flash中，也不会影响在Flash中调试程序。</li>
</ol>
<h2 id="3-调试STM32程序时，某些标志位被调试软件意外清除的问题"><a href="#3-调试STM32程序时，某些标志位被调试软件意外清除的问题" class="headerlink" title="3. 调试STM32程序时，某些标志位被调试软件意外清除的问题"></a>3. 调试STM32程序时，某些标志位被调试软件意外清除的问题</h2><p>　　在调试的过程中，使用调试软件的寄存器或存储器显示窗口，可以很方便地查看外设寄存器的状态。<br>很多朋友都碰到过这样的问题：在单步调试时始终不能在显示窗口看到某些标志位的变化，应该设置这些标志位的时候，窗口中却显示为0，不少人都错误地认为这是芯片的问题。<br>　　我们知道，不少STM32外设的状态寄存器位，可以通过对某些寄存器的读操作而清除(例如I2C的I2C_SR1中的很多标志位)，在调试过程中，每当程序停止在设置的断点或单步停止时，调试软件都会自动地读出所有指定的寄存器和存储器中的内容，并刷新窗口的显示，调试软件的这个读操作恰好清除了那些标志位，造成了上面描述的现象。<br>有几个简单的办法解决这个问题：</p>
<ol>
<li>关闭寄存器或存储器显示窗口。 </li>
<li>在寄存器或存储器显示窗口中不显示这些敏感的寄存器。 </li>
<li>不要把断点放在对这些敏感的寄存器位操作的前面，以保证这些寄存器位不被调试软件意外地操作。 </li>
<li>看官自己添加<del>~</del></li>
</ol>
<p>　　在使用STM32的外设时，由于IO口被用作复用功能，但是外设的初始化正确，GPIO口初始化正确，外设的时钟也已开启，但是外设无法正常运行<br>　　其中最关键的一项，大多数使用者多没有设置，就是某个IO口被用作外设的接口时，需要开启IO口的复用功能的时钟，即进行外设、IO的时钟使能时，需要如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx | RCC_APB2Periph_AFIO, ENABLE);</div><div class="line">/* GPIOx and AFIO clock enable */</div></pre></td></tr></table></figure><br> 　　在使用时，一定要注意该要点！</p>
<h2 id="4-其他关键问题"><a href="#4-其他关键问题" class="headerlink" title="4. 其他关键问题"></a>4. 其他关键问题</h2><p>　　在实际操作过程中，还有两个最关键的地方，一是ST-LINK网上买的都是山寨货，很不稳定，默认频率4M，可以改成1.8M试一试；二是不要使用USB延迟线，会有不稳定的现象。
 　　</p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sw连接 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STM32去掉flash读保护]]></title>
      <url>/2017/06/21/STM32%E5%8E%BB%E6%8E%89flash%E8%AF%BB%E4%BF%9D%E6%8A%A4/</url>
      <content type="html"><![CDATA[<p>STM32有时flash会被读保护，可以通过下列方法去掉。<br>连接板子到PC，进入Dos命令行，进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files &lt;x86&gt;\STMicroelectronics\STM32 ST-LINK Utility\ST-LINK Utility</div></pre></td></tr></table></figure><br>目录下，执行<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ST-Link_CLI.exe -c SWD UR -OB RDP=0</div></pre></td></tr></table></figure><br> 这样就可以把读保护去掉了。</p>
]]></content>
      
        <categories>
            
            <category> 硬件 </category>
            
            <category> stm32 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 写保护 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本博客的编辑格式说明]]></title>
      <url>/2017/06/21/%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BC%96%E8%BE%91%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>本博客采用Hexo + hexo-themes-bubuzou来搭建，核心的格式是markdown，但Hexo也有扩展，bubuzou主题也有少部分扩展，所以要分成这三个部分来说明编辑格式。<br><a id="more"></a></p>
<h2 id="1-markdown格式"><a href="#1-markdown格式" class="headerlink" title="1. markdown格式"></a>1. markdown格式</h2><h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><p>只要在文字前加#就可以表示标题</p>
<pre><code># 一级标题
## 二级标题
</code></pre><p>bubuzou主题自动生成文章段落结构只支持两级标题</p>
<h3 id="1-2-列表"><a href="#1-2-列表" class="headerlink" title="1.2 列表"></a>1.2 列表</h3><p>列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。</p>
<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<h3 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a>1.3 引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可。<br>效果:</p>
<blockquote>
<p>引用的样子</p>
</blockquote>
<h3 id="1-4-插入链接和图片"><a href="#1-4-插入链接和图片" class="headerlink" title="1.4 插入链接和图片"></a>1.4 插入链接和图片</h3><p>插入链接与插入图片的语法很像，区别在一个 !号</p>
<pre><code>链接格式：[链接的文字](http://地址  &quot;鼠标移上去时的气泡提示&quot;)
</code></pre><p>效果:<br><a href="http://www.sina.com.cn" title="提示：" target="_blank" rel="external">新浪</a></p>
<pre><code>图片格式：![图片](http://mouapp.com/Mou_128.png)
</code></pre><p>效果:<br><img src="http://mouapp.com/Mou_128.png" alt="图片"></p>
<p>但是这里只能引用网络上的图片，Hexo可以实现按相对地址加载图片，只需在source文件下建一个文件夹images，把图片放进去，将引用地址改成(/images/图片名称.jpg):<br>    <img src="/images/201706211652_小狗.jpg" alt="图片"></p>
<h3 id="1-5-斜体和粗体"><a href="#1-5-斜体和粗体" class="headerlink" title="1.5 斜体和粗体"></a>1.5 斜体和粗体</h3><p>用两个 /<em> 包含一段文本就是粗体的语法，用一个 /</em> 包含一段文本就是斜体的语法。<br>效果:</p>
<p><strong>粗体</strong>  <em>斜体</em></p>
<h3 id="1-6-表格"><a href="#1-6-表格" class="headerlink" title="1.6 表格"></a>1.6 表格</h3><p>表格的格式如下</p>
<pre><code>| Tables        | Are           | Cool  |
| ------------- |-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
</code></pre><p>效果:</p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:right">Are</th>
<th style="text-align:center">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:right">right-aligned</td>
<td style="text-align:center">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:right">centered</td>
<td style="text-align:center">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:right">are neat</td>
<td style="text-align:center">$1</td>
</tr>
</tbody>
</table>
<h3 id="1-7-代码框"><a href="#1-7-代码框" class="headerlink" title="1.7 代码框"></a>1.7 代码框</h3><p>如果需要在文章里优雅的引用代码框，只需要用两个 ` 把中间的代码包裹起来，但是由于代码中存在各种符号和格式会干扰markdown格式，在hexo的格式中会有更好效果的格式。</p>
<h3 id="1-8-分割线"><a href="#1-8-分割线" class="headerlink" title="1.8 分割线"></a>1.8 分割线</h3><p>分割线的语法只需要三个 * 号，标准的markdown格式可以实现，但是这个主题下不能实现</p>
<p>关于mardown格式更加详细说明，可以参考这个网址<br><a href="http://www.appinn.com/markdown/basic.html" target="_blank" rel="external">markdown格式中文简洁版</a><br><a href="http://wowubuntu.com/markdown" target="_blank" rel="external">markdown格式详细中文版</a></p>
<h2 id="2-Hexo格式"><a href="#2-Hexo格式" class="headerlink" title="2. Hexo格式"></a>2. Hexo格式</h2><p>Hexo自己扩展了很多标签，可以通过官网说明 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">标签插件</a>来查看详细的说明。</p>
<h3 id="2-1-引用块"><a href="#2-1-引用块" class="headerlink" title="2.1 引用块"></a>2.1 引用块</h3><p>Hexo的引用块可以实现很多不同的需求，可以在文章中插入引言，可包含作者、来源和标题。</p>
<pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}
	content
	{% endblockquote %}
</code></pre><p>比如：</p>
<pre><code>{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}
    Every interaction is both precious and an opportunity to delight.
	{% endblockquote %}
</code></pre><p>效果是这样的：<br><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote></p>
<h3 id="2-2-代码块"><a href="#2-2-代码块" class="headerlink" title="2.2 代码块"></a>2.2 代码块</h3><p>Hexo的代码块格式：</p>
<pre><code>{% codeblock [title] [lang:language] [url] [link text] %}
	code snippet
	{% endcodeblock %}
</code></pre><p>比如：</p>
<pre><code>{% codeblock _.compact http://underscorejs.org/#compact Underscore.js %}
    _.compact([0, 1, false, 2, '', 3]);
	=> [1, 2, 3]
	{% endcodeblock %}
</code></pre><p>效果：</p>
<figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div></pre></td></tr></table></figure>
<h3 id="2-3-图片"><a href="#2-3-图片" class="headerlink" title="2.3 图片"></a>2.3 图片</h3><p>在文章中插入指定大小的图片。<br>格式：</p>
<pre><code>{% img [class names] /path/to/image [width] [height] [title text [alt text]] %}
</code></pre><p>比如：</p>
<pre><code>{% img /images/201706211652_小狗.jpg 200 200 提示 %}
</code></pre><p>效果：</p>
<img src="/images/201706211652_小狗.jpg" width="200" height="200" title="提示">
<h3 id="2-4-查看更多内容"><a href="#2-4-查看更多内容" class="headerlink" title="2.4 查看更多内容"></a>2.4 查看更多内容</h3><p>如果只显示文章的一部分，剩余的部分可以通过<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--more--&gt;</div><div class="line"> </div></pre></td></tr></table></figure><br>来查看</p>
<h3 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h3><p>其他如Frame、视频、引用文章等可以通过<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">标签插件</a>来查看。</p>
<h2 id="3-bubuzou主题"><a href="#3-bubuzou主题" class="headerlink" title="3. bubuzou主题"></a>3. bubuzou主题</h2><p>可以查看<a href="https://github.com/Bulandent/hexo-theme-bubuzou/blob/master/doc/doc-zh.md" target="_blank" rel="external">bubuzou主题的中文说明文档</a>来获得更多信息。</p>
<h3 id="3-1-警告块"><a href="#3-1-警告块" class="headerlink" title="3.1 警告块"></a>3.1 警告块</h3><pre><code>主题格式里主要是加了一警告块，这也是如何插入HTML格式的一个实例。
</code></pre><p>  格式如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;tip&quot;&gt;</div><div class="line">   ** 警告**&lt;p&gt;</div><div class="line">   	这是一个警告实例。</div><div class="line">&lt;/div&gt; </div></pre></td></tr></table></figure>
<p>效果：</p>
<div class="tip"><br>    <strong>警告</strong><p><br>        这是一个警告实例。<br></p></div>

]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 格式说明 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
