<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C" /><title> STM32L0 Lorawan调试问题 · 吴亚雄的博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="STM32L0 Lorawan调试问题 - wuyaxiong"><meta name="keywords"><meta name="author" content="wuyaxiong"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="吴亚雄的博客"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="主页" class="nav-list-link">主页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/硬件/" target="_self" data-hover="硬件" class="nav-list-link">硬件</a></li><li class="nav-list-item"><a href="/categories/软件/" target="_self" data-hover="软件" class="nav-list-link">软件</a></li><li class="nav-list-item"><a href="/categories/其他/" target="_self" data-hover="其他" class="nav-list-link">其他</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">STM32L0 Lorawan调试问题</h1><div class="post-info">2017-06-21 19:24</div><div class="post-content"><h2 id="1-RTC-设置和PLL问题"><a href="#1-RTC-设置和PLL问题" class="headerlink" title="1. RTC 设置和PLL问题"></a>1. RTC 设置和PLL问题</h2><p>　　在调试RTC时，时钟一直有问题，后测试发现PLL需要在先设置RCC_CLOCKTYPE_SYSCLK后再设置，不能一次性使用(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);具体原因有待进一步分析，从时钟树的图上开，HCLK、PCLK1、PCLK2都是以SYSCLK为基础的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">void SystemClock_Config( void )</div><div class="line">&#123;</div><div class="line">   RCC_ClkInitTypeDef RCC_ClkInitStruct;</div><div class="line">   RCC_OscInitTypeDef RCC_OscInitStruct;</div><div class="line">  /* Enable Power Control clock */</div><div class="line">  __HAL_RCC_PWR_CLK_ENABLE();</div><div class="line">  /* The voltage scaling allows optimizing the power consumption when the device is </div><div class="line">   clocked below the maximum system frequency, to update the voltage scaling value </div><div class="line">   regarding system frequency refer to product datasheet.  */</div><div class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);</div><div class="line">   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;</div><div class="line">   RCC_OscInitStruct.HSEState = RCC_HSE_ON;</div><div class="line">   RCC_OscInitStruct.LSEState = RCC_LSE_ON;</div><div class="line">   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</div><div class="line">   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</div><div class="line">   RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;</div><div class="line">   RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;</div><div class="line">   HAL_RCC_OscConfig( &amp;RCC_OscInitStruct );</div><div class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;//(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</div><div class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;// RCC_SYSCLKSOURCE_MSI;</div><div class="line">  if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)</div><div class="line">  &#123;</div><div class="line">   /* Initialization Error */</div><div class="line">   Error_Handler();</div><div class="line">  &#125;</div><div class="line">  RCC_ClkInitStruct.ClockType =( RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</div><div class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</div><div class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;  </div><div class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;  </div><div class="line">  if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)</div><div class="line">  &#123;</div><div class="line">   /* Initialization Error */</div><div class="line">   Error_Handler();</div><div class="line">  &#125;</div><div class="line">  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;</div><div class="line">  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;</div><div class="line">  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;</div><div class="line">  if(HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)</div><div class="line">  &#123; </div><div class="line">   while(1)</div><div class="line">   &#123;</div><div class="line">   /* Turn LED3 on */</div><div class="line">   BSP_LED_Toggle(LED3);</div><div class="line">   /* Add a 100ms Delay */</div><div class="line">   HAL_Delay(100);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">  __HAL_RCC_RTC_ENABLE();   </div><div class="line">  /*##-3- Configure the NVIC for RTC Alarm ###################################*/</div><div class="line">  HAL_NVIC_SetPriority(RTC_IRQn, 0x0, 0);</div><div class="line">  HAL_NVIC_EnableIRQ(RTC_IRQn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-RTC时钟设置问题"><a href="#2-RTC时钟设置问题" class="headerlink" title="2. RTC时钟设置问题"></a>2. RTC时钟设置问题</h2><p>　　如果RTC的时钟使用LSE，RTC的计时、闹钟由LSE和SynchPrediv、AsynchPrediv 决定，<br>   1 Hz =32768 / ((AsynchPrediv+1)x(SynchPrediv+1))，<br>　　使用闹钟定时时，除了比较到秒级外，还可以比较subSeconds，subSeconds在设置时间时是不能设置的，它由SynchPrediv决定，新的一秒开始后，它从SynchPrediv开始递减，到0后进入下一秒，实验证明至少要设置到下两个subSeconds才能产生闹钟中断，只有一个不行，如果要设置到1ms的定时，SynchPrediv就需要设置到2047(0x07FF)，这样AsynchPrediv设为0x0F。<br> 　　所以原代码<br>    RtcHandle.Init.AsynchPrediv = 3;<br>    RtcHandle.Init.SynchPrediv =  3;<br>改为<br>    RtcHandle.Init.AsynchPrediv = 0x0F;<br>    RtcHandle.Init.SynchPrediv =  0x07FF;</p>
<h2 id="3-定时器问题"><a href="#3-定时器问题" class="headerlink" title="3. 定时器问题"></a>3. 定时器问题</h2><p>　　原来代码的RtcComputeTimerTimeToAlarmTick输入的是毫秒，在函数里当秒用，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">static RtcCalendar_t RtcComputeTimerTimeToAlarmTick( TimerTime_t timeMiliSecond, RtcCalendar_t now )</div><div class="line">&#123;</div><div class="line">   RtcCalendar_t calendar = now;</div><div class="line">   uint16_t seconds = now.CalendarTime.Seconds;</div><div class="line">   uint16_t minutes = now.CalendarTime.Minutes;</div><div class="line">   uint16_t hours = now.CalendarTime.Hours;</div><div class="line">   uint16_t days = now.CalendarDate.Date;</div><div class="line">   uint32_t nowSubSecondTick=now.CalendarTime.SubSeconds;</div><div class="line">   //double timeoutValueTemp = 0.0;</div><div class="line">   // double timeoutValueSecond = 0.0;</div><div class="line">   // double timeoutValue = 0.0;</div><div class="line">   // double error = 0.0;</div><div class="line">  uint32_t alarmSubSecondTick=0;</div><div class="line">  // int32_t  subSecondTemp=0;</div><div class="line">   timeMiliSecond = MIN( timeMiliSecond, ( TimerTime_t )( RTC_ALARM_MAX_NUMBER_OF_DAYS * SecondsInDay * RTC_ALARM_TICK_DURATION ) );</div><div class="line">   if( timeMiliSecond &lt; 1 )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond = 1;</div><div class="line">   &#125;</div><div class="line">  // timeoutValue is used for complete computation</div><div class="line">  //tickSubSecond = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line"></div><div class="line">  /*</div><div class="line">   // timeoutValueTemp is used to compensate the cumulating errors in timing far in the future</div><div class="line">   timeoutValueTemp =  ( double )timeCounter * RTC_ALARM_TICK_PER_MS;</div><div class="line">   // Compute timeoutValue error</div><div class="line">   error = timeoutValue - timeoutValueTemp;</div><div class="line">   // Add new error value to the cumulated value in uS</div><div class="line">   TimeoutValueError += ( error  * 1000 );</div><div class="line">   // Correct cumulated error if greater than ( RTC_ALARM_TICK_DURATION * 1000 )</div><div class="line">   if( TimeoutValueError &gt;= ( int32_t )( RTC_ALARM_TICK_DURATION * 1000 ) )</div><div class="line">   &#123;</div><div class="line">   TimeoutValueError = TimeoutValueError - ( uint32_t )( RTC_ALARM_TICK_DURATION * 1000 );</div><div class="line">   timeoutValue = timeoutValue + 1;</div><div class="line">   &#125;</div><div class="line"> */</div><div class="line">  // Convert milliseconds to RTC format and add to now</div><div class="line">  //timeoutValueSecond=timeoutValue/1000;</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInDay )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInDay;</div><div class="line">   days++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Calculate hours</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInHour )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInHour;</div><div class="line">   hours++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Calculate minutes</div><div class="line">   while( timeMiliSecond &gt;= MiliSecondsInMinute )</div><div class="line">   &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInMinute;</div><div class="line">   minutes++;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">  while( timeMiliSecond &gt;= MiliSecondsInSecond )</div><div class="line">  &#123;</div><div class="line">   timeMiliSecond -= MiliSecondsInSecond;</div><div class="line">   seconds++;</div><div class="line">  &#125;</div><div class="line">  alarmSubSecondTick = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line">  // Calculate seconds</div><div class="line">  //subSecondTemp=nowSubSecondTick - alarmSubSecondTick;</div><div class="line">  //nowSubSecondTick=nowSubSecondTick + round( timeMiliSecond * RTC_ALARM_TICK_PER_MS );</div><div class="line">  if(nowSubSecondTick &lt; alarmSubSecondTick)</div><div class="line">  &#123;</div><div class="line">   seconds++;</div><div class="line">   alarmSubSecondTick=RTC_ALARM_TICK_PER_SECOND-(alarmSubSecondTick - nowSubSecondTick  );</div><div class="line">  &#125; </div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   alarmSubSecondTick=nowSubSecondTick-alarmSubSecondTick ;</div><div class="line">  &#125;</div><div class="line">  // Correct for modulo</div><div class="line">  while( seconds &gt;= 60 )</div><div class="line">  &#123; </div><div class="line">   seconds -= 60;</div><div class="line">   minutes++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while( minutes &gt;= 60 )</div><div class="line">  &#123;</div><div class="line">   minutes -= 60;</div><div class="line">   hours++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while( hours &gt;= HoursInDay )</div><div class="line">  &#123;</div><div class="line">   hours -= HoursInDay;</div><div class="line">   days++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + Century ) % 4 ) == 0 )</div><div class="line">  &#123;</div><div class="line">   if( days &gt; DaysInMonthLeapYear[now.CalendarDate.Month - 1] )</div><div class="line">   &#123;</div><div class="line">   days = days % DaysInMonthLeapYear[now.CalendarDate.Month - 1];</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   if( days &gt; DaysInMonth[now.CalendarDate.Month - 1] )</div><div class="line">   &#123;   </div><div class="line">   days = days % DaysInMonth[now.CalendarDate.Month - 1];</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">   calendar.CalendarTime.SubSeconds=alarmSubSecondTick;</div><div class="line">   calendar.CalendarTime.Seconds = seconds;</div><div class="line">   calendar.CalendarTime.Minutes = minutes;</div><div class="line">   calendar.CalendarTime.Hours = hours;</div><div class="line">   calendar.CalendarDate.Date = days;</div><div class="line">   return calendar;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br>相应的RtcConvertCalendarTickToTimerTime也改成毫秒，修改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> static TimerTime_t RtcConvertCalendarTickToTimerTime( RtcCalendar_t *calendar )</div><div class="line"> &#123;</div><div class="line">   TimerTime_t timeCounter = 0;</div><div class="line">   RtcCalendar_t now;</div><div class="line">   double timeCounterTemp = 0.0;</div><div class="line">  // Passing a NULL pointer will compute from &quot;now&quot; else,</div><div class="line">  // compute from the given calendar value</div><div class="line">   if( calendar == NULL )</div><div class="line">   &#123;</div><div class="line">   now = RtcGetCalendar( );</div><div class="line">   &#125;</div><div class="line">  else</div><div class="line">   &#123;</div><div class="line">   now = *calendar;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Years (calculation valid up to year 2099)</div><div class="line">   for( int16_t i = 0; i &lt; ( now.CalendarDate.Year + now.CalendarCentury ); i++ )</div><div class="line">   &#123;</div><div class="line">   if( ( i == 0 ) || ( i % 4 ) == 0 )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )SecondsInLeapYear;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )SecondsInYear;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Months (calculation valid up to year 2099)*/</div><div class="line">  if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + now.CalendarCentury ) % 4 ) == 0 )</div><div class="line">   &#123;</div><div class="line">   for( uint8_t i = 0; i &lt; ( now.CalendarDate.Month - 1 ); i++ )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )( DaysInMonthLeapYear[i] * SecondsInDay );</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">   for( uint8_t i = 0;  i &lt; ( now.CalendarDate.Month - 1 ); i++ )</div><div class="line">   &#123;</div><div class="line">   timeCounterTemp += ( double )( DaysInMonth[i] * SecondsInDay );</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  timeCounterTemp += ( double )( ( uint32_t )now.CalendarTime.Seconds +</div><div class="line">                     ( ( uint32_t )now.CalendarTime.Minutes * SecondsInMinute ) +</div><div class="line">                     ( ( uint32_t )now.CalendarTime.Hours * SecondsInHour ) +</div><div class="line">                     ( ( uint32_t )now.CalendarDate.Date * SecondsInDay )  );</div><div class="line"></div><div class="line">   timeCounterTemp = ( double )timeCounterTemp*1000 +(RTC_ALARM_TICK_PER_SECOND- now.CalendarTime.SubSeconds )* RTC_ALARM_TICK_DURATION;</div><div class="line">   timeCounter = round( timeCounterTemp );</div><div class="line">   return ( timeCounter );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-1秒内定时问题"><a href="#3-1秒内定时问题" class="headerlink" title="3. 1秒内定时问题"></a>3. 1秒内定时问题</h2><p>　　RTC时钟只计时到1秒，那么如何定时1秒呢，接收窗口1的延时一般都是1秒，如果在0.9的时候开始设置，那么0.1秒后就产生中断了，显然不合适，这需要设置subSecondsMask，只有在subSecond也一样时才产生中断。<br>    alarmStructure.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;</p>
<h2 id="4-1276初始化问题"><a href="#4-1276初始化问题" class="headerlink" title="4. 1276初始化问题"></a>4. 1276初始化问题</h2><p>　　设置顺序，    SX1276IoIrqInit( DioIrq )原来放在参数写之前，如果这样，在写的时候，可能会参数中断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for( i = 0; i &lt; sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )</div><div class="line">&#123;</div><div class="line"> SX1276SetModem( RadioRegsInit[i].Modem );</div><div class="line"> SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );</div><div class="line">&#125;</div><div class="line">SX1276SetModem( MODEM_FSK );</div><div class="line">SX1276.Settings.State = RF_IDLE;</div><div class="line">SX1276IoIrqInit( DioIrq );</div></pre></td></tr></table></figure><br>　　ST官网的lorawan1.0.1源码解决了以上问题。</p>
<h2 id="5-470的移植问题"><a href="#5-470的移植问题" class="headerlink" title="5. 470的移植问题"></a>5. 470的移植问题</h2><p>　　470和915本来上行和下行的频率不一样。<br>　　在 LoRaMac.c的ResetMacParameters( void )函数中，设置了默认的可用频道，915和470的LoRaMacParams.ChannelsMask并没有被赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> memcpy1( ( uint8_t* ) LoRaMacParams.ChannelsMask, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );</div><div class="line">#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID ) ||defined( USE_BAND_470 )</div><div class="line"> memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>但是在SetNextChannel（）中915又使用了LoRaMacParams.ChannelsMask，显然是有问题的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID )</div><div class="line"> if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )</div><div class="line"> &#123; // Restore default channels</div><div class="line">  memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParams.ChannelsMask, 8 );</div><div class="line"> //这里应该有问题，应该是LoRaMacParamsDefaults.ChannelsMask</div><div class="line"> &#125;</div><div class="line"> if( ( LoRaMacParams.ChannelsDatarate &gt;= DR_4 ) &amp;&amp; ( ( ChannelsMaskRemaining[4] &amp; 0x00FF ) == 0 ) )</div><div class="line"> &#123; // Make sure, that the channels are activated</div><div class="line">  ChannelsMaskRemaining[4] = LoRaMacParams.ChannelsMask[4];</div><div class="line"> &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>   在470使用了 LoRaMacParamsDefaults.ChannelsMask，实测功能正确<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#elif defined( USE_BAND_470 )</div><div class="line">if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )</div><div class="line">&#123; // Restore default channels</div><div class="line"> memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, 12 );</div><div class="line">&#125;</div><div class="line">OnRxWindow1TimerEvent（） 函数中，如果按协议，上下行频率不一样，470应该这样才对：</div><div class="line">// RxWindowSetup( LORAMAC_FIRST_RX2_CHANNEL + ( Channel % 48 ) * LORAMAC_STEPWIDTH_RX2_CHANNEL, datarate,     bandwidth, symbTimeout, false );</div></pre></td></tr></table></figure><br>　　但是实测semtech的服务器上下频率一直，所以用下面的，实测可OTAA 和收发数据<br>    RxWindowSetup( Channels[Channel].Frequency, datarate, bandwidth, symbTimeout, false );</p>
</div></article></div><div class="right-container"><div class="widget"><div class="category"><h4>分类归档</h4><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件/">硬件</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/硬件/stm32/">stm32</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件/树莓派/">树莓派</a><span class="category-list-count">1</span></li></ul></li></ul></div></div><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/ADC/" style="font-size: 10px;">ADC</a> <a href="/tags/DMA/" style="font-size: 20px;">DMA</a> <a href="/tags/SPI/" style="font-size: 10px;">SPI</a> <a href="/tags/UART/" style="font-size: 10px;">UART</a> <a href="/tags/crc8/" style="font-size: 10px;">crc8</a> <a href="/tags/lorawan/" style="font-size: 10px;">lorawan</a> <a href="/tags/sw连接/" style="font-size: 10px;">sw连接</a> <a href="/tags/写保护/" style="font-size: 10px;">写保护</a> <a href="/tags/格式说明/" style="font-size: 10px;">格式说明</a> <a href="/tags/静态IP/" style="font-size: 10px;">静态IP</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/树莓派P3设置静态IP/">树莓派P3设置静态IP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/STM32L052的CRC8硬件实现/">STM32L052的CRC8硬件实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/STM32的ADC测量电压/">STM32的ADC测量电压</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/STM32-Spi-DMA/">STM32 Spi DMA</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/STM32f103-uart-dma-printf串口终极方案/">STM32f103 uart dma printf串口终极方案</a></li></ul></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2017/06/21/STM32f103-uart-dma-printf串口终极方案/" class="prev">PREV</a><a href="/2017/06/21/STM32L0不能连接的问题/" class="next">NEXT</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
    url: document.location.href, 
    sourceId: "",
    productKey: "656e246ebfc7420d82eb5d9a339b50c2",
    target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><div class="copyright"><p>© 2016 - 2017 <a target="_blank">wuyaxiong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a>.</p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>