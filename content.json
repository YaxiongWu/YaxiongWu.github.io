{"meta":{"title":"吴亚雄的博客","subtitle":"吴亚雄的博客","description":null,"author":"wuyaxiong","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-06-22T03:06:12.000Z","updated":"2017-06-22T03:19:18.319Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主介绍 吴亚雄，1982年生，湖南汨罗人。 硬件上系统学习过电子本科课程，应用技术上使用过单片机、ARM、DSP、FPGA，了解的东西多，精的不多。 软件上语言上使用过JS、JSP、C、C++、C#等，使用.NET开发过在用的程序和网页应用，使用C写过不少单片机程序。 QQ:46520368 Email:46520368@qq.com"}],"posts":[{"title":"树莓派P3设置静态IP","slug":"树莓派P3设置静态IP","date":"2017-06-21T11:26:44.000Z","updated":"2017-06-22T02:58:20.773Z","comments":true,"path":"2017/06/21/树莓派P3设置静态IP/","link":"","permalink":"http://yoursite.com/2017/06/21/树莓派P3设置静态IP/","excerpt":"在新的树莓派系统中，静态IP设置的方法与以前有区别，网上很多设置方法无效，正确的设置方法如下。 1. 在/etc/dhcpcd.conf末尾添加12345678910#static ip configurationinterface eth0static ip_address=192.168.100.21/24static routers=192.168.100.1static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4 interface wlan0static ip_address=192.168.100.20/24static routers=192.168.100.1static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4","text":"在新的树莓派系统中，静态IP设置的方法与以前有区别，网上很多设置方法无效，正确的设置方法如下。 1. 在/etc/dhcpcd.conf末尾添加12345678910#static ip configurationinterface eth0static ip_address=192.168.100.21/24static routers=192.168.100.1static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4 interface wlan0static ip_address=192.168.100.20/24static routers=192.168.100.1static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4 2. 重启sudo reboot","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"树莓派","slug":"硬件/树莓派","permalink":"http://yoursite.com/categories/硬件/树莓派/"}],"tags":[{"name":"静态IP","slug":"静态IP","permalink":"http://yoursite.com/tags/静态IP/"}]},{"title":"STM32L052的CRC8硬件实现","slug":"STM32L052的CRC8硬件实现","date":"2017-06-21T11:26:10.000Z","updated":"2017-06-22T02:25:25.003Z","comments":true,"path":"2017/06/21/STM32L052的CRC8硬件实现/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32L052的CRC8硬件实现/","excerpt":"1. 基本原理 CRC是一种数据校验方式，以CRC8为例，如果有一个字节数组，实现过程是：要校验的字节与一个特定的字节（我们暂且叫做多项式字节）相异或，得出的结果再与前一个字节的结果异或，得出的结果再与多项式字节异或，所得的结果为校验值。这个多项式字节是根据科学计算得出的，能让”数据出错但校验位又没有出错“这种情况发生的概率最低，一般CRC8采用下面三种多项式：","text":"1. 基本原理 CRC是一种数据校验方式，以CRC8为例，如果有一个字节数组，实现过程是：要校验的字节与一个特定的字节（我们暂且叫做多项式字节）相异或，得出的结果再与前一个字节的结果异或，得出的结果再与多项式字节异或，所得的结果为校验值。这个多项式字节是根据科学计算得出的，能让”数据出错但校验位又没有出错“这种情况发生的概率最低，一般CRC8采用下面三种多项式：123x8+x5+x4+1 0x31（0x131）x8+x2+x1+1 0x07（0x107） x8+x6+x4+x3+x2+x1 0x5E（0x15E） 2. c语言实现 由于计算一个字节两次要与多项式字节做异或运算，一般可以采用查表的方式更快得到以后结果 如果采用多项式 x8+x5+x4+1，那么0-255与多项式相异或的结果如下表所示：123456789101112131415161718const uint8_t CRC8Table[]=&#123; 0x00,0x31,0x62,0x53,0xc4,0xf5,0xa6,0x97,0xb9,0x88,0xdb,0xea,0x7d,0x4c,0x1f,0x2e, 0x43,0x72,0x21,0x10,0x87,0xb6,0xe5,0xd4,0xfa,0xcb,0x98,0xa9,0x3e,0x0f,0x5c,0x6d, 0x86,0xb7,0xe4,0xd5,0x42,0x73,0x20,0x11,0x3f,0x0e,0x5d,0x6c,0xfb,0xca,0x99,0xa8, 0xc5,0xf4,0xa7,0x96,0x01,0x30,0x63,0x52,0x7c,0x4d,0x1e,0x2f,0xb8,0x89,0xda,0xeb, 0x3d,0x0c,0x5f,0x6e,0xf9,0xc8,0x9b,0xaa,0x84,0xb5,0xe6,0xd7,0x40,0x71,0x22,0x13, 0x7e,0x4f,0x1c,0x2d,0xba,0x8b,0xd8,0xe9,0xc7,0xf6,0xa5,0x94,0x03,0x32,0x61,0x50, 0xbb,0x8a,0xd9,0xe8,0x7f,0x4e,0x1d,0x2c,0x02,0x33,0x60,0x51,0xc6,0xf7,0xa4,0x95, 0xf8,0xc9,0x9a,0xab,0x3c,0x0d,0x5e,0x6f,0x41,0x70,0x23,0x12,0x85,0xb4,0xe7,0xd6, 0x7a,0x4b,0x18,0x29,0xbe,0x8f,0xdc,0xed,0xc3,0xf2,0xa1,0x90,0x07,0x36,0x65,0x54, 0x39,0x08,0x5b,0x6a,0xfd,0xcc,0x9f,0xae,0x80,0xb1,0xe2,0xd3,0x44,0x75,0x26,0x17, 0xfc,0xcd,0x9e,0xaf,0x38,0x09,0x5a,0x6b,0x45,0x74,0x27,0x16,0x81,0xb0,0xe3,0xd2, 0xbf,0x8e,0xdd,0xec,0x7b,0x4a,0x19,0x28,0x06,0x37,0x64,0x55,0xc2,0xf3,0xa0,0x91, 0x47,0x76,0x25,0x14,0x83,0xb2,0xe1,0xd0,0xfe,0xcf,0x9c,0xad,0x3a,0x0b,0x58,0x69, 0x04,0x35,0x66,0x57,0xc0,0xf1,0xa2,0x93,0xbd,0x8c,0xdf,0xee,0x79,0x48,0x1b,0x2a, 0xc1,0xf0,0xa3,0x92,0x05,0x34,0x67,0x56,0x78,0x49,0x1a,0x2b,0xbc,0x8d,0xde,0xef, 0x82,0xb3,0xe0,0xd1,0x46,0x77,0x24,0x15,0x3b,0x0a,0x59,0x68,0xff,0xce,0x9d,0xac&#125;;使用下面的函数就可以得到一个字节数组的CRC8校验值了：12345678910 uint8_t CRC8_Table(uint8_t *p, uint8_t counter) &#123; uint8_t crc8 = 0xff; for( ; counter &gt; 0; counter--)&#123; crc8 = CRC8Table[crc8^*p]; p++; &#125; return crc8; &#125; 3. 在stm32l052中实现CRC 由于CRC在数据传输中要经常用到，Stm32l052有专门的硬件CRC，可以完成7、8、16和32位的CRC， 在官方给出的实例中，实现的是默认32位CRC，下面介绍的如何使用硬件完成CRC8: 12345678910111213141516CrcHandle.Instance = CRC; CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_DISABLE;//DEFAULT_POLYNOMIAL_ENABLE;CrcHandle.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;//CRC_INPUTDATA_FORMAT_WORDS;CrcHandle.Init.CRCLength=CRC_POLYLENGTH_8B;CrcHandle.Init.GeneratingPolynomial=0x31;HAL_CRC_DeInit(&amp;CrcHandle);HAL_CRC_Init(&amp;CrcHandle);if(HAL_CRC_Init(&amp;CrcHandle) != HAL_OK)&#123; Error_Handler();&#125;uwCRCValue = HAL_CRC_Accumulate(&amp;CrcHandle, (uint32_t *)aDataBuffer,24);// BUFFER_SIZE);注意以下几个参数：123456 CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_DISABLE; CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;CrcHandle.Init.CRCLength = CRC_POLYLENGTH_8B;CrcHandle.Init.GeneratingPolynomial = 0x31; 前三个参数是指定使用CRC8，后面GeneratingPolynomial 是多项式，去掉最高位，如 （x8+x5+x4+1）设置为0x31，在实例代码和说明书中，默认的32位CRC为X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2+ X +1，去掉最高位，对应设置的值为0x4C11DB7。 注意 如果设置了为8位，在计算时，HAL_CRC_Accumulate函数的第二个参数虽然是32位的，但最后一个参数是指有多个个字节，这个参数到底是以8位、16位还是32位算，是与设置InputDataFormat相关的. 最后注意使用硬件和代码分别实现时，初始值设置要一致。 通过验证，硬件实现的CRC8与代码实现的一致。","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"crc8","slug":"crc8","permalink":"http://yoursite.com/tags/crc8/"}]},{"title":"STM32的ADC测量电压","slug":"STM32的ADC测量电压","date":"2017-06-21T11:25:45.000Z","updated":"2017-06-22T02:34:00.979Z","comments":true,"path":"2017/06/21/STM32的ADC测量电压/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32的ADC测量电压/","excerpt":"设备使用锂电池供电，需要使用ADC来测量电池电压，使用过程中遇到一些问题记录如下： 1. 硬件 由于电池电压为2.4~4.2v，超过了ADC测量范围，需要分压，为了节约电量，分压采用了比较大的电阻，两个33K，测试时很不准，最后查资料发现是分压电路的电流跟不上，","text":"设备使用锂电池供电，需要使用ADC来测量电池电压，使用过程中遇到一些问题记录如下： 1. 硬件 由于电池电压为2.4~4.2v，超过了ADC测量范围，需要分压，为了节约电量，分压采用了比较大的电阻，两个33K，测试时很不准，最后查资料发现是分压电路的电流跟不上，也可以认为是输入电阻的匹配问题，联想到以前学习的精确测量小电压的差分放大电路，可以得知使用这种大电阻分压无法测得电压值，最后折中的办法是在需测量电压上加了一个2.2uF电容，这样保证测量时的电量供应，改进之后测量基本准确。 2. 软件 在64脚以下的stm32芯片一般没有Vref，只能用芯片电源电压VDD作为ADC的参考电压，但如果是电池供电，该电源电压又是变动的，这就需要利用MCU芯片内部自带基准电压对电源电压进行监测。 每一个型号的基准电压不一致，STM32L052为3v，其他的有为1.2V的，而且一个芯片的校准值也不一样，保存在VREFINT_CAL中，以STM32L052为例，VDDA=3V / VREFINT_CAL/VREFINT_DATA，这里得到的只是ADC测量的参考电压。如果使用12位采样，实际测得的ADC电压值为VDDA/ADC通道采样值/4096。如果电压是稳定的在3.3v，就可以不用测量VDDA这一步了。 这里关键需要厘清的是：内部参考电压VREFINT并非ADC的参考电压，ADC的参考电压依然是VDD。即使VDD有所波动，这个VREFINT电压恒定不变，对于ADC电路而言，它只是个测试点，它的作用是测出VDDA。","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"ADC","slug":"ADC","permalink":"http://yoursite.com/tags/ADC/"}]},{"title":"STM32 Spi DMA","slug":"STM32-Spi-DMA","date":"2017-06-21T11:25:11.000Z","updated":"2017-06-22T02:42:56.221Z","comments":true,"path":"2017/06/21/STM32-Spi-DMA/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32-Spi-DMA/","excerpt":"为了能减轻CPU的负担，考虑使用DMA来操作SPI，但由于SPI为主从模式，主机需要读取从机数据时，也是由主机发起的，如果使用DMA，主机要读从机数据时，先将发送缓存指向发送地址等，使能DMA之后就结束了，需要等到DMA接收完成的中断产生后，才能读接收缓冲，这个过程操作很复杂，","text":"为了能减轻CPU的负担，考虑使用DMA来操作SPI，但由于SPI为主从模式，主机需要读取从机数据时，也是由主机发起的，如果使用DMA，主机要读从机数据时，先将发送缓存指向发送地址等，使能DMA之后就结束了，需要等到DMA接收完成的中断产生后，才能读接收缓冲，这个过程操作很复杂，而且下一次发送时，需要等待判断、等待前一次，启动DMA后，还要等待接收的数据，等中断产生后，才能得带有效的接收数据，所以从效率上来说，只有对存储类和摄像头之类的大块数据才有意义，要频繁改变的小数据没有必要使用DMA，控制太复杂，跟串口的接收数据在形式上有区别。 现将SPI的DMA操作步骤和注意事项记录如下： 1. 初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687SPIx_SCK_GPIO_CLK_ENABLE();SPIx_MISO_GPIO_CLK_ENABLE();SPIx_MOSI_GPIO_CLK_ENABLE();/* Enable SPI clock */SPIx_CLK_ENABLE();/*##-2- Configure peripheral GPIO ##########################################*//* SPI SCK GPIO pin configuration */GPIO_InitTypeDef GPIO_InitStruct;GPIO_InitStruct.Pin = SPIx_SCK_PIN;GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;GPIO_InitStruct.Pull = GPIO_PULLDOWN;GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &amp;GPIO_InitStruct);/* SPI MISO GPIO pin configuration */GPIO_InitStruct.Pin = SPIx_MISO_PIN;HAL_GPIO_Init(SPIx_MISO_GPIO_PORT, &amp;GPIO_InitStruct);/* SPI MOSI GPIO pin configuration */GPIO_InitStruct.Pin = SPIx_MOSI_PIN;HAL_GPIO_Init(SPIx_MOSI_GPIO_PORT, &amp;GPIO_InitStruct);GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;GPIO_InitStruct.Pull = GPIO_PULLUP;GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;GPIO_InitStruct.Pin = RC522_CS_PIN;HAL_GPIO_Init(RC522_CS_GPIO_PORT, &amp;GPIO_InitStruct);RC522_CS_GPIO_CLK_ENABLE();GPIO_InitStruct.Pin = RC522_RESET_PIN;HAL_GPIO_Init(RC522_RESET_GPIO_PORT, &amp;GPIO_InitStruct);RC522_RESET_GPIO_CLK_ENABLE();HAL_GPIO_WritePin(RC522_RESET_GPIO_PORT,RC522_RESET_PIN,1);/*##-3- Configure the NVIC for SPI #########################################*//* NVIC for SPI *//*##-1- Configure the SPI peripheral #######################################*//* Set the SPI parameters */SpiHandle.Instance = SPIx;SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;SpiHandle.Init.Direction = SPI_DIRECTION_2LINES;SpiHandle.Init.CLKPhase = SPI_PHASE_1EDGE;SpiHandle.Init.CLKPolarity = SPI_POLARITY_LOW;SpiHandle.Init.DataSize = SPI_DATASIZE_8BIT;SpiHandle.Init.FirstBit = SPI_FIRSTBIT_MSB;SpiHandle.Init.TIMode = SPI_TIMODE_DISABLE;SpiHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;SpiHandle.Init.CRCPolynomial = 7;SpiHandle.Init.NSS = SPI_NSS_SOFT;SpiHandle.Init.Mode = SPI_MODE_MASTER;if(HAL_SPI_Init(&amp;SpiHandle) != HAL_OK)&#123;/* Initialization Error *///Error_Handler();&#125;__HAL_SPI_ENABLE(&amp;SpiHandle);DMAx_CLK_ENABLE();/*##-3- Configure the DMA ##################################################*//* Configure the DMA handler for Transmission process */hdma_tx.Instance = SPIx_TX_DMA_CHANNEL;hdma_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;hdma_tx.Init.PeriphInc = DMA_PINC_DISABLE;hdma_tx.Init.MemInc = DMA_MINC_ENABLE;hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;hdma_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;hdma_tx.Init.Mode = DMA_NORMAL;hdma_tx.Init.Priority = DMA_PRIORITY_LOW;HAL_DMA_Init(&amp;hdma_tx);/* Associate the initialized DMA handle to the the SPI handle */__HAL_LINKDMA(&amp;SpiHandle, hdmatx, hdma_tx);/* Configure the DMA handler for Transmission process */hdma_rx.Instance = SPIx_RX_DMA_CHANNEL;hdma_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;hdma_rx.Init.PeriphInc = DMA_PINC_DISABLE;hdma_rx.Init.MemInc = DMA_MINC_ENABLE;hdma_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;hdma_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;hdma_rx.Init.Mode = DMA_NORMAL;hdma_rx.Init.Priority = DMA_PRIORITY_HIGH;HAL_DMA_Init(&amp;hdma_rx);/* Associate the initialized DMA handle to the the SPI handle */__HAL_LINKDMA(&amp;SpiHandle, hdmarx, hdma_rx);//DMA_ITConfig(DMA1_Channel5, DMA_IT_TC, ENABLE);/*##-4- Configure the NVIC for DMA #########################################*/ /* NVIC configuration for DMA transfer complete interrupt (SPI2_TX) */HAL_NVIC_SetPriority(SPIx_DMA_TX_IRQn, 0, 1);HAL_NVIC_EnableIRQ(SPIx_DMA_TX_IRQn);/* NVIC configuration for DMA transfer complete interrupt (SPI2_RX) */HAL_NVIC_SetPriority(SPIx_DMA_RX_IRQn, 0, 0);HAL_NVIC_EnableIRQ(SPIx_DMA_RX_IRQn);HAL_NVIC_SetPriority(SPIx_IRQn, 1, 0);HAL_NVIC_EnableIRQ(SPIx_IRQn); 2. 发送接收 注意发送接收缓冲区需要全局变量，因为使用DMA启动后，函数就退出了，如果在函数里使用局部变量，函数退出后变量被回收，这个缓冲区可能会用在别的地方，再对它读写会造成混乱。12345678while(HAL_SPI_GetState(&amp;SpiHandle)!=HAL_SPI_STATE_READY)&#123;&#125;//HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,1);HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,0);if(HAL_SPI_TransmitReceive_DMA(&amp;SpiHandle,txData,rxData,2)!= HAL_OK)&#123;&#125; 3. 中断处理 将NSS脚拉高，清除中断标志。注意DMA中断有DMA的传输一半、传输完成和出错三个中断，如果不判断，传输一半NSS脚会被拉高，也可以在 HAL_SPI_TransmitReceive_DMA( )函数的HAL_DMA_Start_IT()中，屏蔽掉传输过半的中断__HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);1234567891011121314151617 void DMA1_Channel4_IRQHandler(void) &#123; if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(SpiHandle.hdmarx)) != RESET) &#123; if(__HAL_DMA_GET_IT_SOURCE(SpiHandle.hdmarx, DMA_IT_TC) != RESET) &#123; HAL_DMA_IRQHandler(SpiHandle.hdmarx); HAL_GPIO_WritePin(RC522_CS_GPIO_PORT,RC522_CS_PIN,1); &#125; &#125;&#125; void DMA1_Channel5_IRQHandler(void) &#123; HAL_DMA_IRQHandler(SpiHandle.hdmatx); &#125;","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"DMA","slug":"DMA","permalink":"http://yoursite.com/tags/DMA/"},{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"}]},{"title":"STM32f103 uart dma printf串口终极方案","slug":"STM32f103-uart-dma-printf串口终极方案","date":"2017-06-21T11:24:54.000Z","updated":"2017-06-22T02:48:30.113Z","comments":true,"path":"2017/06/21/STM32f103-uart-dma-printf串口终极方案/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32f103-uart-dma-printf串口终极方案/","excerpt":"stm32有dma功能，使用dma功能能大大减少CPU占用率，减少数据传输过程中被中断的几率，但是官方提供的DMA程序是固定长度接收DMA的，DMA接收时只有达到指定的接收长度才会参数中断，但是UART有一个空闲中断，这样可以先开启DMA接收，等UART接收完数据后会产生IDLE中断，进入中断后停掉DMA接收，","text":"stm32有dma功能，使用dma功能能大大减少CPU占用率，减少数据传输过程中被中断的几率，但是官方提供的DMA程序是固定长度接收DMA的，DMA接收时只有达到指定的接收长度才会参数中断，但是UART有一个空闲中断，这样可以先开启DMA接收，等UART接收完数据后会产生IDLE中断，进入中断后停掉DMA接收，通过DMA的剩余接收空间可以得出本次接收到的数据长度。 下面的实验从cube驱动uart的UART_HyperTerminal_DMA实例修改： 1. 前期工作 将各配置按实际的电路板配置好，实现原本实例想实现的定长串口接收功能 2. 在main.c中定义收发需要的参数uint8_t aRxBuffer[RXBUFFERSIZE]; uint8_t UartRecCount=0; uint8_t txbuf2[100]; 在main()主函数中开启IDLE中断 __HAL_UART_ENABLE_IT(&amp;UartHandle, UART_IT_IDLE); 3. 在中断程序中修改IDLE中断响应123456789101112131415161718extern uint8_t aRxBuffer[RXBUFFERSIZE];extern uint8_t UartRecCount;void USARTx_IRQHandler(void)&#123; uint32_t temp; if((__HAL_UART_GET_FLAG(&amp;UartHandle, UART_FLAG_IDLE) != RESET)) &#123; __HAL_UART_CLEAR_IDLEFLAG(&amp;UartHandle); HAL_UART_DMAStop(&amp;UartHandle); temp = UartHandle.hdmarx-&gt;Instance-&gt;CNDTR; UartRecCount = RXBUFFERSIZE - temp; __HAL_UART_ENABLE_IT(&amp;UartHandle, UART_IT_IDLE); UartHandle.hdmarx-&gt;State = HAL_DMA_STATE_READY; HAL_UART_Receive_DMA(&amp;UartHandle,(uint8_t *)aRxBuffer, RXBUFFERSIZE); HAL_UART_Transmit_DMA(&amp;UartHandle, (uint8_t *)aRxBuffer, UartRecCount);//测试，发出收到的变长数据 &#125; HAL_UART_IRQHandler(&amp;UartHandle);&#125; 4. printf 在main.c中123456789101112#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;uint8_t printfBuf[20];void dma_printf(const char *format, ...)&#123; uint32_t length; va_list args; va_start(args, format); length = vsnprintf((char *)printfBuf, sizeof(printfBuf), (char *)format, args); va_end(args); HAL_UART_Transmit_DMA(&amp;UartHandle, (uint8_t *)printfBuf, length);&#125; 之后可以调用dma_printf(“test %d \\n\\r”,10);之类的串口输出","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"DMA","slug":"DMA","permalink":"http://yoursite.com/tags/DMA/"},{"name":"UART","slug":"UART","permalink":"http://yoursite.com/tags/UART/"}]},{"title":"STM32L0 Lorawan调试问题","slug":"STM32L0-Lorawan调试问题","date":"2017-06-21T11:24:04.000Z","updated":"2017-06-22T02:16:39.933Z","comments":true,"path":"2017/06/21/STM32L0-Lorawan调试问题/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32L0-Lorawan调试问题/","excerpt":"1. RTC 设置和PLL问题 在调试RTC时，时钟一直有问题，后测试发现PLL需要在先设置RCC_CLOCKTYPE_SYSCLK后再设置，不能一次性使用(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);具体原因有待进一步分析，从时钟树的图上开，HCLK、PCLK1、PCLK2都是以SYSCLK为基础的。","text":"1. RTC 设置和PLL问题 在调试RTC时，时钟一直有问题，后测试发现PLL需要在先设置RCC_CLOCKTYPE_SYSCLK后再设置，不能一次性使用(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);具体原因有待进一步分析，从时钟树的图上开，HCLK、PCLK1、PCLK2都是以SYSCLK为基础的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void SystemClock_Config( void )&#123; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_OscInitTypeDef RCC_OscInitStruct; /* Enable Power Control clock */ __HAL_RCC_PWR_CLK_ENABLE(); /* The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet. */ __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3); RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.LSEState = RCC_LSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2; HAL_RCC_OscConfig( &amp;RCC_OscInitStruct ); RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;//(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;// RCC_SYSCLKSOURCE_MSI; if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) &#123; /* Initialization Error */ Error_Handler(); &#125; RCC_ClkInitStruct.ClockType =( RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) &#123; /* Initialization Error */ Error_Handler(); &#125; RCC_PeriphCLKInitTypeDef PeriphClkInitStruct; PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; if(HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK) &#123; while(1) &#123; /* Turn LED3 on */ BSP_LED_Toggle(LED3); /* Add a 100ms Delay */ HAL_Delay(100); &#125; &#125; __HAL_RCC_RTC_ENABLE(); /*##-3- Configure the NVIC for RTC Alarm ###################################*/ HAL_NVIC_SetPriority(RTC_IRQn, 0x0, 0); HAL_NVIC_EnableIRQ(RTC_IRQn);&#125; 2. RTC时钟设置问题 如果RTC的时钟使用LSE，RTC的计时、闹钟由LSE和SynchPrediv、AsynchPrediv 决定， 1 Hz =32768 / ((AsynchPrediv+1)x(SynchPrediv+1))， 使用闹钟定时时，除了比较到秒级外，还可以比较subSeconds，subSeconds在设置时间时是不能设置的，它由SynchPrediv决定，新的一秒开始后，它从SynchPrediv开始递减，到0后进入下一秒，实验证明至少要设置到下两个subSeconds才能产生闹钟中断，只有一个不行，如果要设置到1ms的定时，SynchPrediv就需要设置到2047(0x07FF)，这样AsynchPrediv设为0x0F。 所以原代码 RtcHandle.Init.AsynchPrediv = 3; RtcHandle.Init.SynchPrediv = 3;改为 RtcHandle.Init.AsynchPrediv = 0x0F; RtcHandle.Init.SynchPrediv = 0x07FF; 3. 定时器问题 原来代码的RtcComputeTimerTimeToAlarmTick输入的是毫秒，在函数里当秒用，修改如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116static RtcCalendar_t RtcComputeTimerTimeToAlarmTick( TimerTime_t timeMiliSecond, RtcCalendar_t now )&#123; RtcCalendar_t calendar = now; uint16_t seconds = now.CalendarTime.Seconds; uint16_t minutes = now.CalendarTime.Minutes; uint16_t hours = now.CalendarTime.Hours; uint16_t days = now.CalendarDate.Date; uint32_t nowSubSecondTick=now.CalendarTime.SubSeconds; //double timeoutValueTemp = 0.0; // double timeoutValueSecond = 0.0; // double timeoutValue = 0.0; // double error = 0.0; uint32_t alarmSubSecondTick=0; // int32_t subSecondTemp=0; timeMiliSecond = MIN( timeMiliSecond, ( TimerTime_t )( RTC_ALARM_MAX_NUMBER_OF_DAYS * SecondsInDay * RTC_ALARM_TICK_DURATION ) ); if( timeMiliSecond &lt; 1 ) &#123; timeMiliSecond = 1; &#125; // timeoutValue is used for complete computation //tickSubSecond = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS ); /* // timeoutValueTemp is used to compensate the cumulating errors in timing far in the future timeoutValueTemp = ( double )timeCounter * RTC_ALARM_TICK_PER_MS; // Compute timeoutValue error error = timeoutValue - timeoutValueTemp; // Add new error value to the cumulated value in uS TimeoutValueError += ( error * 1000 ); // Correct cumulated error if greater than ( RTC_ALARM_TICK_DURATION * 1000 ) if( TimeoutValueError &gt;= ( int32_t )( RTC_ALARM_TICK_DURATION * 1000 ) ) &#123; TimeoutValueError = TimeoutValueError - ( uint32_t )( RTC_ALARM_TICK_DURATION * 1000 ); timeoutValue = timeoutValue + 1; &#125; */ // Convert milliseconds to RTC format and add to now //timeoutValueSecond=timeoutValue/1000; while( timeMiliSecond &gt;= MiliSecondsInDay ) &#123; timeMiliSecond -= MiliSecondsInDay; days++; &#125; // Calculate hours while( timeMiliSecond &gt;= MiliSecondsInHour ) &#123; timeMiliSecond -= MiliSecondsInHour; hours++; &#125; // Calculate minutes while( timeMiliSecond &gt;= MiliSecondsInMinute ) &#123; timeMiliSecond -= MiliSecondsInMinute; minutes++; &#125; while( timeMiliSecond &gt;= MiliSecondsInSecond ) &#123; timeMiliSecond -= MiliSecondsInSecond; seconds++; &#125; alarmSubSecondTick = round( timeMiliSecond * RTC_ALARM_TICK_PER_MS ); // Calculate seconds //subSecondTemp=nowSubSecondTick - alarmSubSecondTick; //nowSubSecondTick=nowSubSecondTick + round( timeMiliSecond * RTC_ALARM_TICK_PER_MS ); if(nowSubSecondTick &lt; alarmSubSecondTick) &#123; seconds++; alarmSubSecondTick=RTC_ALARM_TICK_PER_SECOND-(alarmSubSecondTick - nowSubSecondTick ); &#125; else &#123; alarmSubSecondTick=nowSubSecondTick-alarmSubSecondTick ; &#125; // Correct for modulo while( seconds &gt;= 60 ) &#123; seconds -= 60; minutes++; &#125; while( minutes &gt;= 60 ) &#123; minutes -= 60; hours++; &#125; while( hours &gt;= HoursInDay ) &#123; hours -= HoursInDay; days++; &#125; if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + Century ) % 4 ) == 0 ) &#123; if( days &gt; DaysInMonthLeapYear[now.CalendarDate.Month - 1] ) &#123; days = days % DaysInMonthLeapYear[now.CalendarDate.Month - 1]; &#125; &#125; else &#123; if( days &gt; DaysInMonth[now.CalendarDate.Month - 1] ) &#123; days = days % DaysInMonth[now.CalendarDate.Month - 1]; &#125; &#125; calendar.CalendarTime.SubSeconds=alarmSubSecondTick; calendar.CalendarTime.Seconds = seconds; calendar.CalendarTime.Minutes = minutes; calendar.CalendarTime.Hours = hours; calendar.CalendarDate.Date = days; return calendar; &#125;相应的RtcConvertCalendarTickToTimerTime也改成毫秒，修改成：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 static TimerTime_t RtcConvertCalendarTickToTimerTime( RtcCalendar_t *calendar ) &#123; TimerTime_t timeCounter = 0; RtcCalendar_t now; double timeCounterTemp = 0.0; // Passing a NULL pointer will compute from &quot;now&quot; else, // compute from the given calendar value if( calendar == NULL ) &#123; now = RtcGetCalendar( ); &#125; else &#123; now = *calendar; &#125; // Years (calculation valid up to year 2099) for( int16_t i = 0; i &lt; ( now.CalendarDate.Year + now.CalendarCentury ); i++ ) &#123; if( ( i == 0 ) || ( i % 4 ) == 0 ) &#123; timeCounterTemp += ( double )SecondsInLeapYear; &#125; else &#123; timeCounterTemp += ( double )SecondsInYear; &#125; &#125; // Months (calculation valid up to year 2099)*/ if( ( now.CalendarDate.Year == 0 ) || ( ( now.CalendarDate.Year + now.CalendarCentury ) % 4 ) == 0 ) &#123; for( uint8_t i = 0; i &lt; ( now.CalendarDate.Month - 1 ); i++ ) &#123; timeCounterTemp += ( double )( DaysInMonthLeapYear[i] * SecondsInDay ); &#125; &#125; else &#123; for( uint8_t i = 0; i &lt; ( now.CalendarDate.Month - 1 ); i++ ) &#123; timeCounterTemp += ( double )( DaysInMonth[i] * SecondsInDay ); &#125; &#125; timeCounterTemp += ( double )( ( uint32_t )now.CalendarTime.Seconds + ( ( uint32_t )now.CalendarTime.Minutes * SecondsInMinute ) + ( ( uint32_t )now.CalendarTime.Hours * SecondsInHour ) + ( ( uint32_t )now.CalendarDate.Date * SecondsInDay ) ); timeCounterTemp = ( double )timeCounterTemp*1000 +(RTC_ALARM_TICK_PER_SECOND- now.CalendarTime.SubSeconds )* RTC_ALARM_TICK_DURATION; timeCounter = round( timeCounterTemp ); return ( timeCounter );&#125; 3. 1秒内定时问题 RTC时钟只计时到1秒，那么如何定时1秒呢，接收窗口1的延时一般都是1秒，如果在0.9的时候开始设置，那么0.1秒后就产生中断了，显然不合适，这需要设置subSecondsMask，只有在subSecond也一样时才产生中断。 alarmStructure.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE; 4. 1276初始化问题 设置顺序， SX1276IoIrqInit( DioIrq )原来放在参数写之前，如果这样，在写的时候，可能会参数中断12345678for( i = 0; i &lt; sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )&#123; SX1276SetModem( RadioRegsInit[i].Modem ); SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );&#125;SX1276SetModem( MODEM_FSK );SX1276.Settings.State = RF_IDLE;SX1276IoIrqInit( DioIrq ); ST官网的lorawan1.0.1源码解决了以上问题。 5. 470的移植问题 470和915本来上行和下行的频率不一样。 在 LoRaMac.c的ResetMacParameters( void )函数中，设置了默认的可用频道，915和470的LoRaMacParams.ChannelsMask并没有被赋值。1234 memcpy1( ( uint8_t* ) LoRaMacParams.ChannelsMask, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID ) ||defined( USE_BAND_470 ) memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );#endif 但是在SetNextChannel（）中915又使用了LoRaMacParams.ChannelsMask，显然是有问题的，1234567891011#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID ) if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 ) &#123; // Restore default channels memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParams.ChannelsMask, 8 ); //这里应该有问题，应该是LoRaMacParamsDefaults.ChannelsMask &#125; if( ( LoRaMacParams.ChannelsDatarate &gt;= DR_4 ) &amp;&amp; ( ( ChannelsMaskRemaining[4] &amp; 0x00FF ) == 0 ) ) &#123; // Make sure, that the channels are activated ChannelsMaskRemaining[4] = LoRaMacParams.ChannelsMask[4]; &#125; 在470使用了 LoRaMacParamsDefaults.ChannelsMask，实测功能正确 1234567#elif defined( USE_BAND_470 )if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )&#123; // Restore default channels memcpy1( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, 12 );&#125;OnRxWindow1TimerEvent（） 函数中，如果按协议，上下行频率不一样，470应该这样才对：// RxWindowSetup( LORAMAC_FIRST_RX2_CHANNEL + ( Channel % 48 ) * LORAMAC_STEPWIDTH_RX2_CHANNEL, datarate, bandwidth, symbTimeout, false ); 但是实测semtech的服务器上下频率一直，所以用下面的，实测可OTAA 和收发数据 RxWindowSetup( Channels[Channel].Frequency, datarate, bandwidth, symbTimeout, false );","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"lorawan","slug":"lorawan","permalink":"http://yoursite.com/tags/lorawan/"}]},{"title":"STM32L0不能连接的问题","slug":"STM32L0不能连接的问题","date":"2017-06-21T11:23:44.000Z","updated":"2017-06-22T00:17:02.022Z","comments":true,"path":"2017/06/21/STM32L0不能连接的问题/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32L0不能连接的问题/","excerpt":"1. 问题 前期使用STM32L052+SX1276模块时，遇到了几个问题： 使用买来的，已经写好代码的MODEM，直接就不认，一直纠结于硬件问题，或是启动设置的问题，其实是写好的代码中，将SW调试端口用作了IO口，只要正常运行后，就无法正常的用作SW，所以一直连不上，ST-LINK软件的提示是有意义的，它提示使用硬件RESET，这个在”STM32 ST-LINK Utility”和keil中都有地方设置，原理就是SW的IO口做别的用了，就通过RESET来复位到SW，一般是点击连接，或下载，或调试时，立即按下RESET，很快松开，可正常使用","text":"1. 问题 前期使用STM32L052+SX1276模块时，遇到了几个问题： 使用买来的，已经写好代码的MODEM，直接就不认，一直纠结于硬件问题，或是启动设置的问题，其实是写好的代码中，将SW调试端口用作了IO口，只要正常运行后，就无法正常的用作SW，所以一直连不上，ST-LINK软件的提示是有意义的，它提示使用硬件RESET，这个在”STM32 ST-LINK Utility”和keil中都有地方设置，原理就是SW的IO口做别的用了，就通过RESET来复位到SW，一般是点击连接，或下载，或调试时，立即按下RESET，很快松开，可正常使用 FLASH的读保护问题 在连接FLASH后，提示读保护，网上大部分是让从RAM运行一段FLASH解锁的代码，有些复杂，没有成功。 解决办法： 连接板子与PC，进入Dos命令行，进入C:\\Program Files \\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility目录下，执行ST-Link_CLI.exe -c SWD UR -OB RDP=0 这样就可以把读保护去掉了。 2. 网上有价值的信息 很多人都碰到过调试器不能连接到STM32的问题，不管是IAR的J-Link还是Keil的ULink，或者是ST的ST-Link。出现这个问题时，调试软件会提示不能建立与Cortex-M3的连接，或提示不能下载程序，或提示找不到要调试的设备等。这样的问题都是发生在调试那些可以在CPU不干预的时候自动运行的模块、或在调试低功耗模式的程序的时候。所谓“可以在CPU不干预的时候自动运行的模块”包括：DMA、定时器、连续转换模式下的ADC、看门狗等模块。 这个问题的根源是： 调试器需要在RAM内执行一段程序，对Flash进行擦写操作，如果不停止这些自动运行的模块，它们会干扰程序在RAM中的执行，致使下载失败。比如DMA模块被配置为不停地拷贝一段数据区，而调试器刚好需要使用DMA数据传输的目标区域，这时DMA的操作将会与调试器的操作发生冲突。再比如，如果启动了看门狗而没有执行硬件复位，则在下次调试器需要下载程序时，看门狗超时将触发芯片复位，导致下载操作失败。 低功耗是通过停止CPU的时钟而实现，JTAG调试是通过与CPU的通信实现，停止了CPU的时钟致使调试器会失去与CPU的通信。 有人说“我停止调试的时候，这些模块已经停止了运行，应该不会干扰到后续的调试”，这个问题要从几方面看： 调试器是通过停止CPU核心的时钟来停止被调试程序的运行，实际上被调试芯片的硬件模块并没有被复位，它们还处于使能状态，那些能够自动运行的模块只是处于暂停状态，一旦恢复了时钟之后，它们仍会继续运行。 目前常用的调试软件，不管是IAR EWARM还是Keil MDK，调试软件界面上的”复位”按钮都不能对芯片执行硬件的复位，这个”复位”按钮只能对芯片内的程序执行软件复位，即把运行指针重新指向复位地址。 使用板上的复位按钮可以手动地进行硬件复位，使所有模块(包括那些能够自动运行的模块)停止工作并恢复到复位状态。但是当调试器需要控制CPU之前，它需要先为CPU核心提供时钟，然后需要较长的一段时间做一些初始化的动作，然后才能接管CPU核心的控制权。在调试器为CPU核心提供时钟之后，用户程序就已经开始运行起来，如果用户程序在调试器接管CPU核心的控制权之前，就初始化好硬件模块并启动运行，则仍然会产生与调试器的冲突。 根据以上的分析，解决这个问题的关键是，在调试器接管CPU核心的控制权之前，必须停止所有能够自动运行模块的操作，使它们处于关闭状态，要做到这一点，可以有以下几种方案： 每次退出调试状态时，先停止所有模块的运行，比如执行该模块的DeInit()操作。 在main()函数开始时，不管各模块处于什么状态，先执行该模块的DeInit()操作，然后在程序中较晚的时间或真正需要时再开启相应的模块。这样保证在刚进入调试状态时，调试器能够有充足的时间完成初始化和下载程序的操作。先执行该模块的DeInit()操作的目的是为了关闭哪些上一次操作开启的模块。 调整BOOT0/BOOT1的设置，把启动模式改变为从内部SRAM启动，再结合手工硬件复位。由于BOOT0/BOOT1的状态只在硬件复位时是有意义的，而调试器不做硬件复位，所以这样的设置不会影响调试器下载程序到Flash中，也不会影响在Flash中调试程序。 3. 调试STM32程序时，某些标志位被调试软件意外清除的问题 在调试的过程中，使用调试软件的寄存器或存储器显示窗口，可以很方便地查看外设寄存器的状态。很多朋友都碰到过这样的问题：在单步调试时始终不能在显示窗口看到某些标志位的变化，应该设置这些标志位的时候，窗口中却显示为0，不少人都错误地认为这是芯片的问题。 我们知道，不少STM32外设的状态寄存器位，可以通过对某些寄存器的读操作而清除(例如I2C的I2C_SR1中的很多标志位)，在调试过程中，每当程序停止在设置的断点或单步停止时，调试软件都会自动地读出所有指定的寄存器和存储器中的内容，并刷新窗口的显示，调试软件的这个读操作恰好清除了那些标志位，造成了上面描述的现象。有几个简单的办法解决这个问题： 关闭寄存器或存储器显示窗口。 在寄存器或存储器显示窗口中不显示这些敏感的寄存器。 不要把断点放在对这些敏感的寄存器位操作的前面，以保证这些寄存器位不被调试软件意外地操作。 看官自己添加~ 在使用STM32的外设时，由于IO口被用作复用功能，但是外设的初始化正确，GPIO口初始化正确，外设的时钟也已开启，但是外设无法正常运行 其中最关键的一项，大多数使用者多没有设置，就是某个IO口被用作外设的接口时，需要开启IO口的复用功能的时钟，即进行外设、IO的时钟使能时，需要如下代码：12RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx | RCC_APB2Periph_AFIO, ENABLE);/* GPIOx and AFIO clock enable */ 在使用时，一定要注意该要点！ 4. 其他关键问题 在实际操作过程中，还有两个最关键的地方，一是ST-LINK网上买的都是山寨货，很不稳定，默认频率4M，可以改成1.8M试一试；二是不要使用USB延迟线，会有不稳定的现象。","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"sw连接","slug":"sw连接","permalink":"http://yoursite.com/tags/sw连接/"}]},{"title":"STM32去掉flash读保护","slug":"STM32去掉flash读保护","date":"2017-06-21T11:22:47.000Z","updated":"2017-06-22T02:54:53.989Z","comments":true,"path":"2017/06/21/STM32去掉flash读保护/","link":"","permalink":"http://yoursite.com/2017/06/21/STM32去掉flash读保护/","excerpt":"STM32有时flash会被读保护，可以通过下列方法去掉。连接板子到PC，进入Dos命令行，进入1C:\\Program Files &lt;x86&gt;\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility目录下，执行","text":"STM32有时flash会被读保护，可以通过下列方法去掉。连接板子到PC，进入Dos命令行，进入1C:\\Program Files &lt;x86&gt;\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility目录下，执行1ST-Link_CLI.exe -c SWD UR -OB RDP=0 这样就可以把读保护去掉了。","categories":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/categories/硬件/"},{"name":"stm32","slug":"硬件/stm32","permalink":"http://yoursite.com/categories/硬件/stm32/"}],"tags":[{"name":"写保护","slug":"写保护","permalink":"http://yoursite.com/tags/写保护/"}]},{"title":"本博客的编辑格式说明","slug":"博客的编辑格式说明","date":"2017-06-21T07:54:06.000Z","updated":"2017-06-22T02:29:07.477Z","comments":true,"path":"2017/06/21/博客的编辑格式说明/","link":"","permalink":"http://yoursite.com/2017/06/21/博客的编辑格式说明/","excerpt":"本博客采用Hexo + hexo-themes-bubuzou来搭建，核心的格式是markdown，但Hexo也有扩展，bubuzou主题也有少部分扩展，所以要分成这三个部分来说明编辑格式。","text":"本博客采用Hexo + hexo-themes-bubuzou来搭建，核心的格式是markdown，但Hexo也有扩展，bubuzou主题也有少部分扩展，所以要分成这三个部分来说明编辑格式。 1. markdown格式1.1 标题只要在文字前加#就可以表示标题 # 一级标题 ## 二级标题 bubuzou主题自动生成文章段落结构只支持两级标题 1.2 列表列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 1 2 3 1.3 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可。效果: 引用的样子 1.4 插入链接和图片插入链接与插入图片的语法很像，区别在一个 !号 链接格式：[链接的文字](http://地址 &quot;鼠标移上去时的气泡提示&quot;) 效果:新浪 图片格式：![图片](http://mouapp.com/Mou_128.png) 效果: 但是这里只能引用网络上的图片，Hexo可以实现按相对地址加载图片，只需在source文件下建一个文件夹images，把图片放进去，将引用地址改成(/images/图片名称.jpg): 1.5 斜体和粗体用两个 / 包含一段文本就是粗体的语法，用一个 / 包含一段文本就是斜体的语法。效果: 粗体 斜体 1.6 表格表格的格式如下 | Tables | Are | Cool | | ------------- |-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 效果: Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 1.7 代码框如果需要在文章里优雅的引用代码框，只需要用两个 ` 把中间的代码包裹起来，但是由于代码中存在各种符号和格式会干扰markdown格式，在hexo的格式中会有更好效果的格式。 1.8 分割线分割线的语法只需要三个 * 号，标准的markdown格式可以实现，但是这个主题下不能实现 关于mardown格式更加详细说明，可以参考这个网址markdown格式中文简洁版markdown格式详细中文版 2. Hexo格式Hexo自己扩展了很多标签，可以通过官网说明 标签插件来查看详细的说明。 2.1 引用块Hexo的引用块可以实现很多不同的需求，可以在文章中插入引言，可包含作者、来源和标题。 {% blockquote [author[, source]] [link] [source_link_title] %} content {% endblockquote %} 比如： {% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %} Every interaction is both precious and an opportunity to delight. {% endblockquote %} 效果是这样的：Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 2.2 代码块Hexo的代码块格式： {% codeblock [title] [lang:language] [url] [link text] %} code snippet {% endcodeblock %} 比如： {% codeblock _.compact http://underscorejs.org/#compact Underscore.js %} _.compact([0, 1, false, 2, '', 3]); => [1, 2, 3] {% endcodeblock %} 效果： _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 2.3 图片在文章中插入指定大小的图片。格式： {% img [class names] /path/to/image [width] [height] [title text [alt text]] %} 比如： {% img /images/201706211652_小狗.jpg 200 200 提示 %} 效果： 2.4 查看更多内容如果只显示文章的一部分，剩余的部分可以通过 12&lt;!--more--&gt; 来查看 2.4 其他其他如Frame、视频、引用文章等可以通过标签插件来查看。 3. bubuzou主题可以查看bubuzou主题的中文说明文档来获得更多信息。 3.1 警告块主题格式里主要是加了一警告块，这也是如何插入HTML格式的一个实例。 格式如下： 1234&lt;div class=&quot;tip&quot;&gt; ** 警告**&lt;p&gt; 这是一个警告实例。&lt;/div&gt; 效果： 警告 这是一个警告实例。","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"格式说明","slug":"格式说明","permalink":"http://yoursite.com/tags/格式说明/"}]}]}